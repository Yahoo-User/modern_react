*******************************************************
* 03. List of Built-in React Hooks                    *
*******************************************************


---------------------------------
01. useCallback
---------------------------------

	const cachedFn = useCallback(fn, dependencies)

â–  The "useCallback" is a React Hook that lets you cache a function definition between re-renders.
  --------------------------------
  "useCallback"ì€, ì¬ë Œë”ë§ ì‚¬ì´ì— í•¨ìˆ˜ì •ì˜ë¥¼ ìºì‹œí•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ”, React Hookì…ë‹ˆë‹¤.


â–  Reference

	"useCallback(fn, dependencies)"


  â—‹ Description
  	Call useCallback at the top level of your component to cache a "function definition" between "re-renders" :
  --------------------------------
	ë‹¹ì‹ ì˜ ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useCallback" í˜¸ì¶œí•˜ì—¬, "ì¬ë Œë”ë§" ê°„ì— "í•¨ìˆ˜ì •ì˜"ë¥¼ ìºì‹œí•©ë‹ˆë‹¤ :


  â—‹ ë§¤ê°œë³€ìˆ˜(Parameters)

	â‘  fn: The function value that you want to cache.
		- It can take any arguments and return any values.
		- React will return (not call!) your function back to you during the initial render.
		- On next renders, React will give you the same function again
		  if the dependencies have not changed since the last render.
		  Otherwise, it will give you the function that you have passed during the current render,
		  and store it in case it can be reused later.
		- React will not call your function.
		- The function is returned to you so you can decide when and whether to call it.
		---------------------------------
		â— ìºì‹œí•  í•¨ìˆ˜ê°’ ì…ë‹ˆë‹¤. 
		- ëª¨ë“  ì¸ìë¥¼ ì‚¬ìš©í•˜ê³ , ëª¨ë“  ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
		- ReactëŠ” ì´ˆê¸° ë Œë”ë§ ì¤‘ì—, ë‹¹ì‹ ì˜ í•¨ìˆ˜ë¥¼, ë‹¹ì‹ ì—ê²Œ ë‹¤ì‹œ ë°˜í™˜í•©ë‹ˆë‹¤. (í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤!).
		- ë‹¤ìŒ ë Œë”ë§ì—ì„œ, ReactëŠ” ë§ˆì§€ë§‰ ë Œë”ë§ ì´í›„,
		  ì˜ì¡´ì„±("dependencies")ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°, ë™ì¼í•œ í•¨ìˆ˜ë¥¼ ë‹¤ì‹œ ì œê³µí•©ë‹ˆë‹¤.
		  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, í˜„ì¬ ë Œë”ë§ ì¤‘ì— ê°œë°œìê°€ ì „ë‹¬í•œ í•¨ìˆ˜ë¥¼ ì œê³µí•˜ê³ , ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì €ì¥í•©ë‹ˆë‹¤.
		- ReactëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 
		- í•¨ìˆ˜ê°€ ê°œë°œìì—ê²Œ ë°˜í™˜ë˜ë¯€ë¡œ, í•´ë‹¹ í•¨ìˆ˜ì˜ í˜¸ì¶œ ì‹œê¸°ì™€ ì—¬ë¶€ë¥¼ ê²°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	â‘¡ dependencies: The list of all "reactive" values referenced inside of the "fn" code. 
		- The "reactive" values include "props", "state", 
		  and all the "variables" and "functions" declared directly inside your component body.
		- If your linter is configured for React,
		  it will verify that every reactive value is correctly specified as a dependency.
		- The list of dependencies must have a constant number of items and 
		  be written inline like "[dep1, dep2, dep3]".
		- React will compare each dependency with its previous value using the "Object.is" comparison algorithm.
		---------------------------------
		â— fn ì½”ë“œ ë‚´ì—ì„œ ì°¸ì¡°ë˜ëŠ” ëª¨ë“  ë°˜ì‘ê°’ì˜ ëª©ë¡ì…ë‹ˆë‹¤.
		- ë°˜ì‘í˜•(reactive) ê°’ì—ëŠ” â‘  "props"  â‘¡ "state" 
		  ê·¸ë¦¬ê³  â‘¢ ì»´í¬ë„ŒíŠ¸ "ë³¸ë¬¸" ë‚´ë¶€ì— ì§ì ‘ ì„ ì–¸ëœ ëª¨ë“  "ë³€ìˆ˜"ì™€ "í•¨ìˆ˜"ê°€ í¬í•¨ë©ë‹ˆë‹¤.
		- linterê°€ React ìš©ìœ¼ë¡œ êµ¬ì„±ëœ ê²½ìš°,
		  ëª¨ë“  ë°˜ì‘í˜•(reactive) ê°’ì´ ì¢…ì†ì„±(dependencies)ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ì§€ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
		- ì¢…ì†ì„± ëª©ë¡(DL)ì—ëŠ” ì¼ì •í•œ ìˆ˜ì˜ í•­ëª©ì´ ìˆì–´ì•¼ í•˜ë©°, 
		  "[dep1, dep2, dep3]" ì™€ ê°™ì´ ì¸ë¼ì¸ìœ¼ë¡œ ì‘ì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
		- ReactëŠ” "Object.is" ë¹„êµ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬, ê° ì¢…ì†ì„±(dependency)ì„ ì´ì „ê°’ê³¼ ë¹„êµí•©ë‹ˆë‹¤.


  â—‹ ë°˜í™˜(Returns): On the initial render, "useCallback" returns the "fn" function you have passed.

		- During subsequent renders, it will either return an already stored "fn" function
		  from the last render(if the dependencies havenâ€™t changed),
		  or return the "fn" function you have passed during this render.
		---------------------------------
		â— ì´ˆê¸° ë Œë”ë§ì—ì„œ, "useCallback"ëŠ” ì „ë‹¬í•œ fní•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

		- í›„ì† ë Œë”ë§ ì¤‘ì—ëŠ”, ë§ˆì§€ë§‰ ë Œë”ë§ì—ì„œ ì´ë¯¸ ì €ì¥ëœ fn í•¨ìˆ˜(ì¢…ì†ì„±ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°)ë¥¼ ë°˜í™˜í•˜ê±°ë‚˜, 
		  ì´ ë Œë”ë§ ì¤‘ì— ì „ë‹¬í•œ fn í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.


â–  ì£¼ì˜ì‚¬í•­(Caveats) 

  â—‹ useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks.
  â—‹ You canâ€™t call it inside loops or conditions.
  â—‹ If you need that, extract a new component and move the state into it.
  â—‹ React will not throw away the cached function unless there is a specific reason to do that.
  	For example, in development, React throws away the cache when you edit the file of your component.
  	Both in development and in production,
	React will throw away the cache if your component suspends during the initial mount.
  â—‹ In the future, React may add more features that take advantage of throwing away the cache\
    for example, if React adds built-in support for virtualized lists in the future, 
  	it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. 
  â—‹ This should match your expectations if you rely on useCallback as a performance optimization. 
  	Otherwise, a state variable or a ref may be more appropriate.
  ---------------------------------
  â—‹ "useCallback" ëŠ” Hookì´ë¯€ë¡œ, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ë ˆë²¨ ë˜ëŠ” ìì‹ ì˜ Hookì—ì„œë§Œ, í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
  â—‹ ë£¨í”„ ë˜ëŠ” ì¡°ê±´ ë‚´ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
  â—‹ í•„ìš”í•œ ê²½ìš°, ìƒˆ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìƒíƒœ(state)ë¥¼ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¡œ ì´ë™í•©ë‹ˆë‹¤.
  â—‹ ReactëŠ” íŠ¹ë³„í•œ ì´ìœ ê°€ ì—†ëŠ” í•œ, ìºì‹œëœ í•¨ìˆ˜ë¥¼ ë²„ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤. 
	ì˜ˆë¥¼ë“¤ì–´, ê°œë°œ ì¤‘ì— ReactëŠ”, ì»´í¬ë„ŒíŠ¸ì˜ íŒŒì¼ì„ í¸ì§‘í•  ë•Œ, ìºì‹œë¥¼ ë²„ë¦½ë‹ˆë‹¤. 
	ê°œë°œê³¼ í”„ë¡œë•ì…˜ ëª¨ë‘ì—ì„œ, ReactëŠ” ì´ˆê¸° ë§ˆìš´íŠ¸ ì¤‘ì— ì»´í¬ë„ŒíŠ¸ê°€ ì¼ì‹œì¤‘ë‹¨ë˜ë©´, ìºì‹œë¥¼ ë²„ë¦½ë‹ˆë‹¤.
  â—‹ ì•ìœ¼ë¡œ ReactëŠ” ìºì‹œë¥¼ ë²„ë¦¬ëŠ” ê²ƒì„ í™œìš©í•˜ëŠ” ë” ë§ì€ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	ì˜ˆë¥¼ë“¤ì–´, Reactê°€ ë¯¸ë˜ì— ê°€ìƒí™”ëœ ëª©ë¡ì— ëŒ€í•œ ë‚´ì¥ì§€ì›ì„ ì¶”ê°€í•œë‹¤ë©´,
	ê°€ìƒí™”ëœ í…Œì´ë¸” ë·°í¬íŠ¸ì—ì„œ ìŠ¤í¬ë¡¤ë˜ëŠ” í•­ëª©ì— ëŒ€í•œ ìºì‹œë¥¼ ë²„ë¦¬ëŠ” ê²ƒì´ í•©ë¦¬ì ì¼ ê²ƒì…ë‹ˆë‹¤.
  â—‹ ì´ëŠ” ì„±ëŠ¥ ìµœì í™”ì—, "useCallback"ì„ ì˜ì¡´í•˜ëŠ” ê²½ìš°, ê¸°ëŒ€ì¹˜ì™€ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
	ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ìƒíƒœë³€ìˆ˜(state variable) ë˜ëŠ” "ref"ê°€ ë” ì ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


â–  ì‚¬ìš©ë²• #1 - Skipping re-rendering of components

  â—‹ ë Œë”ë§ ì„±ëŠ¥ì„ ìµœì í™” í•  ë•Œ, ìì‹ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬í•  "í•¨ìˆ˜"ë¥¼ ìºì‹œí•´ì•¼ í•˜ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤.
  â—‹ ë¨¼ì € ì´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ êµ¬ë¬¸ì„ ì‚´í´ë³¸ ë‹¤ìŒ, ì–´ë–¤ ê²½ìš°ì— ìœ ìš©í•œì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

  â—‹ ì»´í¬ë„ŒíŠ¸ê°€, "re-rendering" í•˜ëŠ” ì‚¬ì´ì—, í•¨ìˆ˜ë¥¼ ìºì‹œí•˜ë ¤ë©´, í•´ë‹¹ í•¨ìˆ˜ì •ì˜ë¥¼ "useCallback" Hookìœ¼ë¡œ ë˜í•‘í•˜ì„¸ìš”:

		import { useCallback } from 'react';

		function ProductPage({ productId, referrer, theme }) {

			const handleSubmit = useCallback((orderDetails) => {		<--- ***
				post('/product/' + productId + '/buy', {
					referrer,
					orderDetails,
				});
			}, [productId, referrer]);

			// ...

  â—‹ ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ "useCallback" hookì— ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤.

	1. "Function Definition"	- "re-rendering" ê°„ì— ìºì‹œí•˜ë ¤ëŠ” í•¨ìˆ˜ì •ì˜ ì…ë‹ˆë‹¤.
	2. "Dependency List" 		- í•¨ìˆ˜ ì•ˆì—ì„œ ì‚¬ìš©ë˜ëŠ” ì»´í¬ë„ŒíŠ¸ ë‚´ì˜ ëª¨ë“  ê°’ì„ í¬í•¨í•©ë‹ˆë‹¤.

  â—‹ ì´ˆê¸° ë Œë”ë§ ì‹œ, ê°œë°œìê°€ "useCallback"ì—ì„œ ì–»ê²Œ ë  ë°˜í™˜ëœ í•¨ìˆ˜ëŠ”,
    ê°œë°œìê°€ ì „ë‹¬í•œ ë°”ë¡œ ê·¸ í•¨ìˆ˜ê°€ ë  ê²ƒì…ë‹ˆë‹¤.

  â—‹ ê·¸ ë‹¤ìŒ ë Œë”ë§ì—ì„œ, ReactëŠ” í˜„ì¬ ì¢…ì†ì„±ì„, ì´ì „ ë Œë”ë§ ì¤‘ì— ì „ë‹¬í•œ ì¢…ì†ì„±ê³¼ ë¹„êµí•©ë‹ˆë‹¤.

	ë¹„êµê²°ê³¼, ì¢…ì†ì„±ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°, (Object.isìœ¼ë¡œ ë¹„êµí•˜ì—¬)
	"useCallback" í›…ì€ ì´ì „ê³¼ ë™ì¼í•œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

	ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, "useCallback" í›…ì€ í˜„ì¬ ë Œë”ë§ì—ì„œ ì „ë‹¬í•œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

  â—‹ ì¦‰, "useCallback" í›…ì€, ì¢…ì†ì„±ì´ ë³€ê²½ë  ë•Œê¹Œì§€, "re-renders" ì‚¬ì´ì—, í•´ë‹¹ í•¨ìˆ˜ë¥¼ ìºì‹œí•©ë‹ˆë‹¤.

  â—‹ ì´ê²ƒì´ ì–¸ì œ ìœ ìš©í•œì§€ ì•Œì•„ë³´ê¸° ìœ„í•´, ì˜ˆì œë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:

	- ProductPage ì»´í¬ë„ŒíŠ¸ì—ì„œ handleSubmit í•¨ìˆ˜ë¥¼, ê·¸ ì•„ë˜ ShippingForm ì»´í¬ë„ŒíŠ¸ë¡œ, ì „ë‹¬í•œë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤.

		function ProductPage({ productId, referrer, theme }) {
			// ...

			return (
				<div className={theme}>
				<ShippingForm onSubmit={handleSubmit} />
				</div>
			);

  â—‹ ë§Œì¼ "theme" prop ë¥¼ í† ê¸€í•˜ë©´ ì•±ì´ ì ì‹œ ë©ˆì¶”ì§€ë§Œ,
	ê°œë°œìì˜ "JSX"ì—ì„œ "<ShippingForm />"ì„ ì œê±°í•˜ë©´ ë¹ ë¥´ê²Œ ëŠê»´ì§ì„, ê°œë°œìëŠ” ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	ì´ê²ƒì€ ê°œë°œìì—ê²Œ "ShippingForm" ì»´í† ë„ŒíŠ¸ë¥¼ ìµœì í™”í•  ê°€ì¹˜ê°€ ìˆìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤.

  â—‹ ê¸°ë³¸ì ìœ¼ë¡œ, ì»´í¬ë„ŒíŠ¸ê°€ ì¬ë Œë”ë§ ë  ë•Œ, ReactëŠ” ëª¨ë“  ìì‹ì„ ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ ë Œë”ë§í•©ë‹ˆë‹¤.
	ì´ê²ƒì´ ë°”ë¡œ ProductPageê°€ ë‹¤ë¥¸ themeë¡œ ì¬ë Œë”ë§ í•  ë•Œ, ShippingForm ì»´í¬ë„ŒíŠ¸ë„ ì¬ë Œë”ë§ ë˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤.
	ì´ê²ƒì€, ì¬ë Œë”ë§í•˜ëŠ” ë° ë§ì€ ê³„ì‚°ì´ í•„ìš”í•˜ì§€ ì•Šì€ ì»´í¬ë„ŒíŠ¸ì—ëŠ” ì í•©í•©ë‹ˆë‹¤.

  â—‹	ê·¸ëŸ¬ë‚˜ ì¬ë Œë”ë§ì´ ëŠë¦° ê²ƒì„ í™•ì¸í•œ ê²½ìš°ì—ëŠ”, ë‹¤ìŒê³¼ ì˜ˆì œì™€ ê°™ì´, 
	ShippingForm ì»´í¬ë„ŒíŠ¸ì˜ "props"ì´ ë§ˆì§€ë§‰ ë Œë”ë§ê³¼ ë™ì¼í•  ë•Œ, í•´ë‹¹ ì»´í† ë„ŒíŠ¸ë¥¼ "memo"ë¡œ ë˜í•‘í•˜ì—¬,
	ShippingForm ì»´í¬ë„ŒíŠ¸ì˜ ì¬ë Œë”ë§ì„ ê±´ë„ˆë›°ë„ë¡ ì§€ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

	  	import { memo } from 'react';

		const ShippingForm = memo(function ShippingForm({ onSubmit }) {
			// ...
		});

  â—‹ ì´ ë³€ê²½ìœ¼ë¡œ, ShippingForm ì»´í¬ë„ŒíŠ¸ëŠ” ìê¸°ì˜ ëª¨ë“  "props"ê°€ ë§ˆì§€ë§‰ ë Œë”ë§ê³¼ ë™ì¼í•œ ê²½ìš°, ì¬ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤.
	ì´ê²ƒì´ ë°”ë¡œ ì–¸ì œ í•¨ìˆ˜ë¥¼ ìºì‹±í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•´ì§ˆ ë•Œ ì…ë‹ˆë‹¤!					<--- ***

  â—‹ "useCallback" hook ì—†ì´, handleSubmit í•¨ìˆ˜ë¥¼ ì •ì˜í–ˆë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤:

		function ProductPage({ productId, referrer, theme }) {

			// Every time the "theme" changes, this will be a "different" function...	(***)
			function handleSubmit(orderDetails) {
				post('/product/' + productId + '/buy', {
					referrer,
					orderDetails,
				});
			} // handleSubmit
			
			return (
				<div className={theme}>
					{/* ... so ShippingForm's "props" will never be the same, and it will re-render every time */}	<--- ***
					<ShippingForm onSubmit={handleSubmit} />
				</div>
			);

		} // ProductPage

  â—‹ JavaScriptì—ì„œ "function() {}" ë˜ëŠ” "() => {}"ëŠ” í•­ìƒ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
	ì´ëŠ” "{}" ê°ì²´ ë¦¬í„°ëŸ´ì´ í•­ìƒ ìƒˆ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ë°©ì‹ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤.
	  
	ì¼ë°˜ì ìœ¼ë¡œ, ì´ëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ, ì´ê²ƒì€ ShippingFormì˜ "props"ì´ ê²°ì½” ë™ì¼í•˜ì§€ ì•Šìœ¼ë©°, 
	ë©”ëª¨ ìµœì í™”(memo optimization)ê°€ ì‘ë™í•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

  â—‹	"useCallback" ì´ ìœ ìš©í•œ ê³³ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

		function ProductPage({ productId, referrer, theme }) {

			// 1. Tell React to cache your function between re-renders...
			const handleSubmit = useCallback((orderDetails) => {			<--- ***
				post('/product/' + productId + '/buy', {
					referrer,
					orderDetails,
				});
			}, [productId, referrer]); // 2. ...so as long as these dependencies don't change...

			return (
				<div className={theme}>
					{/* 3. ...ShippingForm will receive the same "props" and can "skip" re-rendering */}
					<ShippingForm onSubmit={handleSubmit} />
				</div>
			);
		} // ProductPage

  â—‹ By wrapping handleSubmit in useCallback,
  	you ensure that itâ€™s the same function between the re-renders (until dependencies change).
	
	You donâ€™t have to wrap a function in useCallback unless you do it for some specific reason.
	In this example, the reason is that you pass it to a component wrapped in memo, 
	and this lets it skip re-rendering.
	
	There are other reasons you might need useCallback which are described further on this page.

  â—‹ handleSubmitì„ useCallbackìœ¼ë¡œ ë˜í•‘í•˜ë©´, 
    (ì¢…ì†ì„±ì´ ë³€ê²½ë  ë•Œê¹Œì§€ëŠ”) ì¬ë Œë”ë§í•  ë•Œ ë™ì¼í•œ í•¨ìˆ˜ê°€ ë˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    íŠ¹ë³„í•œ ì´ìœ ê°€ ì—†ëŠ” í•œ, "useCallback"í›…ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ë˜í•‘ í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
	
	ì´ ì˜ˆì œì—ì„œ, ê·¸ ì´ìœ ëŠ” "memo"ë¡œ ë˜í•‘ëœ ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬í•˜ì—¬, ì¬ë Œë”ë§ì„ ê±´ë„ˆë›¸ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
	ì´ í˜ì´ì§€ì— ìì„¸íˆ ì„¤ëª…ëœ ë‹¤ë¥¸ ì´ìœ ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

  â—‹ Note : ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ì„œë§Œ, "useCallback"ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

	ì½”ë“œê°€ ì‘ë™í•˜ì§€ ì•Šìœ¼ë©´, ë¨¼ì € ê·¼ë³¸ì ì¸ ë¬¸ì œë¥¼ ì°¾ì•„ ìˆ˜ì •í•˜ì‹­ì‹œì˜¤.
	ê·¸ëŸ° ë‹¤ìŒ ë‹¤ì‹œ "useCallback" ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


â–  ì‚¬ìš©ë²• #2 - Updating "state" from a "memoized" callback

  â—‹ Sometimes, you might need to update state based on previous state from a memoized callback.
  	ë•Œë¡œëŠ”, ë©”ëª¨ëœ(memoized) ì½œë°±ì˜ ì´ì „ ìƒíƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ, ìƒíƒœ(state)ë¥¼ ì—…ë°ì´íŠ¸ í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
  
  â—‹ This handleAddTodo function specifies todos as a dependency because it computes the next todos from it:
  	ì´ handlerAddTodo í•¨ìˆ˜ëŠ” ë‹¤ìŒ í•  ì¼ì„ ê³„ì‚°í•˜ê¸° ë•Œë¬¸ì—, í•  ì¼ì„ ì¢…ì†ì„±ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤:

		function TodoList() {
			const [todos, setTodos] = useState([]);				<--- ***

			const handleAddTodo = useCallback((text) => {		<--- ***
				const newTodo = { id: nextId++, text };

				setTodos([...todos, newTodo]);					<--- ***
			}, [todos]);

			// ...

  â—‹ Youâ€™ll usually want memoized functions to have as few dependencies as possible.

  	When you read some state only to calculate the next state, 
	you can remove that dependency by passing an updater function instead:

	---------------------------------

	ì¼ë°˜ì ìœ¼ë¡œ ë©”ëª¨ëœ(memoized) í•¨ìˆ˜ì—ëŠ” ê°€ëŠ¥í•œ í•œ ì ì€ ì¢…ì†ì„±ì„ ê°–ê¸°ë¥¼ ì›í•  ê²ƒì…ë‹ˆë‹¤.

	ë‹¤ìŒ ìƒíƒœë¥¼ ê³„ì‚°í•˜ê¸° ìœ„í•´ ì¼ë¶€ ìƒíƒœ(state)ë¥¼ ì½ëŠ” ê²½ìš°,
	ëŒ€ì‹  ì—…ë°ì´íŠ¸ í•¨ìˆ˜(updater function)ë¥¼ ì „ë‹¬í•˜ì—¬, í•´ë‹¹ ì¢…ì†ì„±ì„ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

	---------------------------------

		function TodoList() {
			const [todos, setTodos] = useState([]);				<--- ***

			const handleAddTodo = useCallback((text) => {
				const newTodo = { id: nextId++, text };

				setTodos(todos => [...todos, newTodo]);			<--- ***
			}, []); // âœ… No need for the "todos" dependency

			// ...

  â—‹ Here, instead of making todos a dependency and reading it inside,
  	you pass an instruction about how to update the state (todos => [...todos, newTodo]) to React.

	---------------------------------

	ì—¬ê¸°ì—ì„œëŠ”, todosë¥¼ ì¢…ì†ì„±ìœ¼ë¡œ ë§Œë“¤ê³  ë‚´ë¶€ì—ì„œ ì½ëŠ” ëŒ€ì‹ , 
	ìƒíƒœ(state) (todos => [...todos, newTodo])ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ì§€ì¹¨ì„, Reactì— ì „ë‹¬í•©ë‹ˆë‹¤.


â–  Troubleshooting #1 - Every time my component renders, "useCallback" returns a different function

  â—‹ Make sure youâ€™ve specified the dependency array as a second argument!

  â—‹ If you forget the dependency array, "useCallback" will return a new function every time:

		function ProductPage({ productId, referrer }) {

			const handleSubmit = useCallback((orderDetails) => {				<--- ***
				post('/product/' + productId + '/buy', {
					referrer,
					orderDetails,
				});
			}); // ğŸ”´ Returns a new function every time: no dependency array	<--- ***

			// ...

  â—‹ This is the "corrected" version passing the "dependency array" as a second argument:

		function ProductPage({ productId, referrer }) {

			const handleSubmit = useCallback((orderDetails) => {				<--- ***
				post('/product/' + productId + '/buy', {
					referrer,
					orderDetails,
				});
			}, [productId, referrer]); // âœ… Does not return a new function unnecessarily	<--- ***

			// ...

  â—‹ If this doesnâ€™t help, then the problem is that at least one of your dependencies is different from the previous render.
  	You can debug this problem by manually logging your dependencies to the console:

		const handleSubmit = useCallback((orderDetails) => {					<--- ***
			// ..
		}, [productId, referrer]);

		console.log([productId, referrer]);										<--- ***

  â—‹ You can then right-click on the arrays from different re-renders in the console 
  	and select â€œStore as a global variableâ€ for both of them. 
	
	Assuming the first one got saved as temp1 and the second one got saved as temp2, 
	you can then use the browser console to check whether each dependency in both arrays is the same:

		Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?		<--- ***
		Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?		<--- ***
		Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...					<--- ***

  â—‹ When you find which dependency is breaking memoization,
  	either find a way to remove it, or memoize it as well.


â–  Troubleshooting #2 - I need to call "useCallback" for each list item in a loop, but itâ€™s not allowed

  â—‹ Suppose the Chart component is wrapped in "memo".

    You want to skip "re-rendering" every Chart in the list when the ReportList component re-renders.
	However, you canâ€™t call "useCallback" in a "loop":

		function ReportList({ items }) {											<--- ***
			return (	
				<article>
					{items.map(item => {
						// ğŸ”´ You can't call "useCallback" in a loop like this:
						const handleClick = useCallback(() => {						<--- *** : XX
							sendReport(item)
						}, [item]);

						return (
							<figure key={item.id}>
								<Chart onClick={handleClick} />
							</figure>
						);
					})}
				</article>
			);
		}

  â—‹ Instead, extract a component for an individual item, and put "useCallback" there:

		function ReportList({ items }) {						<--- ***
			return (	
				<article>
					{items.map(item =>
						<Report key={item.id} item={item} />	<--- ***
					)}
				</article>
			);
		}

		function Report({ item }) {								<--- ***
			// âœ… Call "useCallback" at the top level:
			const handleClick = useCallback(() => {				<--- ***
				sendReport(item)
			}, [item]);

			return (
				<figure>
					<Chart onClick={handleClick} />
				</figure>
			);
		}

  â—‹ Alternatively, you could remove "useCallback" in the last snippet and instead wrap Report itself in "memo".
  	If the item prop does not change, Report will "skip" re-rendering, so Chart will "skip" re-rendering too:

		function ReportList({ items }) {						<--- ***
			// ...
		}

		const Report = memo(function Report({ item }) {			<--- ***
			function handleClick() {
				sendReport(item);
			}

			return (
				<figure>
					<Chart onClick={handleClick} />
				</figure>
			);
		});


---------------------------------
02. useContext
---------------------------------

	const value = useContext(SomeContext)

â–  The "useContext" is a React Hook that lets you read and subscribe to "context" from your "component".
	(Component ì—ì„œ context ë¥¼ ì½ê³  êµ¬ë…í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React Hook)


â–  Example

	import { useContext } from 'react';

	function MyComponent() {
		const theme = useContext(ThemeContext);				<--- ***

		// ...


â–  Reference

		useContext(SomeContext)

  â—‹ Call "useContext" at the top level of your component to read and subscribe to "context".
	---------------------------------
	"context"ë¥¼ ì½ê³  êµ¬ë…í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ, "useContext"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.

		import { useContext } from 'react';

		function MyComponent() {
			const theme = useContext(ThemeContext);
			// ...

  â—‹ Parameters
	â‘  SomeContext
	   	- The "context" that youâ€™ve previously created with "createContext".
	   	- The "context" itself does *NOT* hold the information,
	   	  it *ONLY* represents the "kind" of information you can provide or read from "components".
		---------------------------------
	   	- ì´ì „ì— "createContext"ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±í•œ "ì»¨í…ìŠ¤íŠ¸"ì…ë‹ˆë‹¤.
		- "ì»¨í…ìŠ¤íŠ¸" ìì²´ëŠ” ì •ë³´ë¥¼ *í¬í•¨í•˜ì§€* ì•Šìœ¼ë©°, 
		  *ì˜¤ì§* "ì»´í¬ë„ŒíŠ¸"ì—ì„œ ì œê³µí•˜ê±°ë‚˜ ì½ì„ ìˆ˜ ìˆëŠ” ì •ë³´ì˜ "ì¢…ë¥˜"ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

  â—‹ Returns
	â— "useContext" returns the "context" value for the calling "component".
	â— It is determined as the value passed to the closest "SomeContext".
	â— "Provider" above the calling component in the tree.
	â— If there is no such "provider",
	  then the returned value will be the "defaultValue" you have passed to "createContext" for that "context".
	â— The returned value is *Always* up-to-date.
	â— React automatically re-renders "components" that read some "context" if it changes.
	---------------------------------
	â— "useContext"ëŠ” í˜¸ì¶œ ì»´í¬ë„ŒíŠ¸ì— ëŒ€í•œ ì»¨í…ìŠ¤íŠ¸ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	â— ê°€ì¥ ê°€ê¹Œìš´ "SomeContext"ì— ì „ë‹¬ëœ ê°’ìœ¼ë¡œ ê²°ì •ë©ë‹ˆë‹¤.
	â— íŠ¸ë¦¬ì—ì„œ í˜¸ì¶œ "ì»´í¬ë„ŒíŠ¸" ìœ„ì— ìˆëŠ” "ê³µê¸‰ì"ì…ë‹ˆë‹¤.
	â— ê·¸ëŸ¬í•œ "ê³µê¸‰ì"ê°€ ì—†ëŠ” ê²½ìš°, ë°˜í™˜ëœ ê°’ì€ í•´ë‹¹ "ì»¨í…ìŠ¤íŠ¸"ì— ëŒ€í•´, "createContext"ì— ì „ë‹¬í•œ "defaultValue"ê°€ ë©ë‹ˆë‹¤.
	â— ë°˜í™˜ëœ ê°’ì€ *í•­ìƒ* ìµœì‹ ìƒíƒœì…ë‹ˆë‹¤.
	â— ReactëŠ” "ì»¨í…ìŠ¤íŠ¸"ê°€ ë³€ê²½ë˜ë©´, ì¼ë¶€ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì½ëŠ” "ì»´í¬ë„ŒíŠ¸"ë¥¼ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ë Œë”ë§ í•©ë‹ˆë‹¤.

  â—‹ Caveats
	â— "useContext()" call in a component is *NOT* affected by "providers" returned from the same "component".
	  The corresponding "<Context.Provider>" needs to be above the "component" doing the "useContext()" call.
	â— React automatically re-renders all the children that use a particular context starting from the "provider" that receives a different value.
	  The previous and the next values are compared with the "Object.is" comparison.
	  Skipping re-renders with "memo" does *NOT* prevent the children receiving fresh context values.
	â— If your build system produces duplicates modules in the output (which can happen with "symlinks"), this can break "context".
	  Passing something via context only works if "SomeContext" that you use to provide "context" 
	  and "SomeContext" that you use to read it are exactly the same object, as determined by "a === comparison".
	---------------------------------
	â— ì»´í¬ë„ŒíŠ¸ì˜ "useContext()" í˜¸ì¶œì€, ë™ì¼ "ì»´í¬ë„ŒíŠ¸"ì—ì„œ ë°˜í™˜ëœ "ì œê³µì"ì˜ ì˜í–¥ì„ ë°›ì§€ *ì•ŠìŠµë‹ˆë‹¤*.
	  í•´ë‹¹ "<Context.Provider>"ëŠ” "useContext()" í˜¸ì¶œì„ ìˆ˜í–‰í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
	â— ReactëŠ”, ë‹¤ë¥¸ ê°’ì„ ë°›ëŠ” "ì œê³µì"ë¶€í„° ì‹œì‘í•˜ì—¬, íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  í•˜ìœ„ í•­ëª©ì„, ìë™ìœ¼ë¡œ ë‹¤ì‹œ ë Œë”ë§í•©ë‹ˆë‹¤.
	  "Object.is" ë¹„êµë¥¼ í†µí•´, ì´ì „ê°’ê³¼ ë‹¤ìŒê°’ì„ ë¹„êµí•©ë‹ˆë‹¤.
	  "ë©”ëª¨"ë¥¼ ì‚¬ìš©í•˜ì—¬, ì¬ë Œë”ë§ì„ ê±´ë„ˆë›°ì–´ë„, í•˜ìœ„í•­ëª©ì´ ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ê°’ì„ ìˆ˜ì‹ í•˜ëŠ” ê²ƒì´ *ì•„ë‹™ë‹ˆë‹¤*.
	â— ë¹Œë“œ ì‹œìŠ¤í…œì´ ì¶œë ¥ì— ì¤‘ë³µëª¨ë“ˆì„ ìƒì„±í•˜ëŠ” ê²½ìš°("symlinks"ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆìŒ), ì´ë¡œì¸í•´ "ì»¨í…ìŠ¤íŠ¸"ê°€ ì¤‘ë‹¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  ì»¨í…ìŠ¤íŠ¸ë¥¼ í†µí•´ ë¬´ì–¸ê°€ë¥¼ ì „ë‹¬í•˜ëŠ” ê²ƒì€, "ì»¨í…ìŠ¤íŠ¸"ë¥¼ ì œê³µí•˜ëŠ”ë° ì‚¬ìš©í•˜ëŠ” "SomeContext"ì™€ ì´ë¥¼ ì½ëŠ”ë° ì‚¬ìš©í•˜ëŠ” "SomeContext"ê°€
	  "a === ë¹„êµ"ì— ì˜í•´ ê²°ì •ëœ ëŒ€ë¡œ ì •í™•íˆ ë™ì¼í•œ ê°œì²´ì¸ ê²½ìš°ì—ë§Œ, ì‘ë™í•©ë‹ˆë‹¤.


â–  Usage #1 - Passing data deeply into the tree.

  â—‹ Call "useContext" at the top level of your component to read and subscribe to "context":
	---------------------------------
	"context"ë¥¼ ì½ê³  êµ¬ë…í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ, "useContext"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”:

		import { useContext } from 'react';

		function Button() {
			const theme = useContext(ThemeContext);
			// ...

  â—‹ "useContext" returns the "context value" for the "context" you passed.
    To determine the "context value", React searches the "component tree"
	and finds the closest "context provider" above for that particular "context".
	---------------------------------
	"useContext"ëŠ”, ì „ë‹¬í•œ "ì»¨í…ìŠ¤íŠ¸"ì— ëŒ€í•œ "ì»¨í…ìŠ¤íŠ¸ê°’"ì„, ë°˜í™˜í•©ë‹ˆë‹¤.
	"ì»¨í…ìŠ¤íŠ¸ê°’"ì„ ê²°ì •í•˜ê¸° ìœ„í•´, ReactëŠ” "ì»´í¬ë„ŒíŠ¸ íŠ¸ë¦¬"ë¥¼ ê²€ìƒ‰í•˜ê³ , 
	íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ì— ëŒ€í•´, ìœ„ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ "ì»¨í…ìŠ¤íŠ¸ ê³µê¸‰ì"ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

  â—‹ To pass "context" to a Button,
  	wrap it or one of its parent components into the corresponding "context provider":
	---------------------------------
	"ì»¨í…ìŠ¤íŠ¸"ë¥¼ Buttonì— ì „ë‹¬í•˜ë ¤ë©´,
	í•´ë‹¹ "ì»¨í…ìŠ¤íŠ¸ ì œê³µì"ì—, í•´ë‹¹ ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ ì¤‘ í•˜ë‚˜ë¥¼ ë˜í•‘í•©ë‹ˆë‹¤:

		function MyPage() {
			return (
				<ThemeContext.Provider value="dark">			<--- ***
					<Form />
				</ThemeContext.Provider>
			);
		}

		function Form() {
			// ... renders buttons inside ...					<--- ***
		}

  â—‹ It doesnâ€™t matter how many layers of components there are between the "provider" and the Button.
    When a Button anywhere inside of Form calls "useContext(ThemeContext)", it will receive "dark" as the "value".
	---------------------------------
	ê³µê¸‰ìì™€ ë²„íŠ¼ ì‚¬ì´ì—, ëª‡ ê°œì˜ ì»´í¬ë„ŒíŠ¸ ë ˆì´ì–´ê°€ ìˆëŠ”ì§€ëŠ” ì¤‘ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	Form ë‚´ë¶€ì˜ Buttonì´ "useContext(ThemeContext)"ë¥¼ í˜¸ì¶œí•˜ë©´, ê°’ìœ¼ë¡œ "dark"ê°€ ìˆ˜ì‹ ë©ë‹ˆë‹¤.

  â—‹ Pitfall (ìœ„í—˜)
	"useContext()" always looks for the closest "provider" above the component that calls it.
	It searches upwards and does *NOT* consider "providers" in the component from which youâ€™re calling "useContext()".
	---------------------------------
	"useContext()"ëŠ” í•­ìƒ, ì´ë¥¼ í˜¸ì¶œí•˜ëŠ” ì»´í¬ë„ŒíŠ¸ ìœ„ì—ì„œ, ê°€ì¥ ê°€ê¹Œìš´ "ì œê³µì"ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
	ìœ„ìª½ìœ¼ë¡œ ê²€ìƒ‰í•˜ë©°, "useContext()"ë¥¼ í˜¸ì¶œí•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì˜ "ì œê³µì"ë¥¼ ê³ ë ¤í•˜ì§€ *ì•ŠìŠµë‹ˆë‹¤*.

  â—‹ Example:  App.js

		import { createContext, useContext } from 'react';

		const ThemeContext = createContext(null);						<--- ***

		export default function MyApp() {
			return (
				<ThemeContext.Provider value="dark">					<--- ***
					<Form />
				</ThemeContext.Provider>
			)
		}

		function Form() {
			return (
				<Panel title="Welcome">									<--- ***
					<Button>Sign up</Button>							<--- ***
					<Button>Log in</Button>								<--- ***
				</Panel>
			);
		}

		function Panel({ title, children }) {
			const theme = useContext(ThemeContext);						<--- ***

			const className = 'panel-' + theme;

			return (
				<section className={className}>
					<h1>{title}</h1>
					{children}
				</section>
			)
		}

		function Button({ children }) {
			const theme = useContext(ThemeContext);						<--- ***
			const className = 'button-' + theme;

			return (
				<button className={className}>
					{children}
				</button>
			);
		}


â–  Usage #2 - Updating data passed via context.

  â—‹ Often, youâ€™ll want the "context" to change over time.
  	To update "context", combine it with "state".
    Declare a "state variable" in the parent component, and pass the current state down as the "context value" to the "provider" :
	---------------------------------
	ì¢…ì¢… ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼, "ì»¨í…ìŠ¤íŠ¸"ê°€ ë³€ê²½ë˜ê¸°ë¥¼ ì›í•  ê²ƒì…ë‹ˆë‹¤.
	"ì»¨í…ìŠ¤íŠ¸"ë¥¼ ì—…ë°ì´íŠ¸í•˜ë ¤ë©´, "ìƒíƒœ"ì™€ ê²°í•©í•˜ì„¸ìš”.
	ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì—ì„œ "ìƒíƒœë³€ìˆ˜"ë¥¼ ì„ ì–¸í•˜ê³ , "í˜„ì¬ìƒíƒœ"ë¥¼ "ì»¨í…ìŠ¤íŠ¸ê°’"ìœ¼ë¡œ "ì œê³µì"ì— ì „ë‹¬í•©ë‹ˆë‹¤:

		function MyPage() {
			const [theme, setTheme] = useState('dark');							<--- ***

			return (
				<ThemeContext.Provider value={theme}>							<--- ***
					<Form />

					<Button onClick={() => { setTheme('light'); }}>				<--- ***
						Switch to light theme
					</Button>
				</ThemeContext.Provider>
			);
		}

  â—‹ Now any Button inside of the "provider" will receive the current theme value.
    If you call "setTheme" to update the theme value that you pass to the "provider",
	all Button components will "re-render" with the new 'light' value.
	---------------------------------
	ì´ì œ "ê³µê¸‰ì" ë‚´ë¶€ì˜ ëª¨ë“  ë²„íŠ¼ì€ í˜„ì¬ í…Œë§ˆê°’ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.
	"setTheme"ë¥¼ í˜¸ì¶œí•˜ì—¬, "ê³µê¸‰ì"ì— ì „ë‹¬í•˜ëŠ” í…Œë§ˆê°’ì„ ì—…ë°ì´íŠ¸í•˜ë©´,
	ëª¨ë“  Button ì»´í¬ë„ŒíŠ¸ê°€ ìƒˆë¡œìš´ 'light' ê°’ìœ¼ë¡œ "ë‹¤ì‹œ ë Œë”ë§"ë©ë‹ˆë‹¤.			<--- ***

  â—‹ Example: App.js

		import { createContext, useContext, useState } from 'react';


		const ThemeContext = createContext(null);								<--- ***

		export default 
		function MyApp() {
			const [theme, setTheme] = useState('light');						<--- ***

			return (
				<ThemeContext.Provider value={theme}>							<--- ***
					<Form />

					<label>
						<input
							type="checkbox"
							checked={theme === 'dark'}							<--- ***
							onChange={(e) => { 
								setTheme(e.target.checked ? 'dark' : 'light')	<--- ***
							}} />
						Use dark mode
					</label>
				</ThemeContext.Provider>
			)
		}

		function Form({ children }) {
			return (
				<Panel title="Welcome">											<--- ***
					<Button>Sign up</Button>									<--- ***
					<Button>Log in</Button>										<--- ***
				</Panel>
			);
		}

		function Panel({ title, children }) {
			const theme = useContext(ThemeContext);								<--- ***
			const className = 'panel-' + theme;

			return (
				<section className={className}>
					<h1>{title}</h1>
					{children}
				</section>
			)
		}

		function Button({ children }) {
			const theme = useContext(ThemeContext);								<--- ***
			const className = 'button-' + theme;

			return (
				<button className={className}>
					{children}
				</button>
			);
		}


---------------------------------
03. useDebugValue
---------------------------------	

â–  The "useDebugValue" is a React Hook that lets you add a label to a custom Hook in React DevTools.
	(React DevToolsì—ì„œ, Custom Hookì— ë¼ë²¨ì„ ì¶”ê°€í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React Hook)

	useDebugValue(value, format?)

â–  Example

	import { useDebugValue } from 'react';

	function useOnlineStatus() {
		// ...

		useDebugValue(isOnline ? 'Online' : 'Offline');

		// ...
	}


---------------------------------
04. useDeferredValue
---------------------------------

â–  The "useDeferredValue" is a React Hook that lets you defer updating a part of the UI.
	(UIì˜ ì¼ë¶€ ì—…ë°ì´íŠ¸ë¥¼ ì—°ê¸°í•  ìˆ˜ ìˆëŠ” React Hook)

	const deferredValue = useDeferredValue(value)

â–  Example

	import { useState, useDeferredValue } from 'react';

	function SearchPage() {
		const [query, setQuery] = useState('');
		const deferredQuery = useDeferredValue(query);

		// ...
	}


---------------------------------
05. useEffect
---------------------------------

   useEffect(setup, dependencies?)

â–  "useEffect" is a React Hook that lets you synchronize a component with an external system.
  ---------------------------------
  "useEffect"ëŠ” ì»´í¬ë„ŒíŠ¸ë¥¼ ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ ë™ê¸°í™”í•  ìˆ˜ ìˆëŠ” React Hook ì…ë‹ˆë‹¤.

â–  Reference

  â—‹ Call "useEffect" at the top level of a React component to declare an "Effect":
  	---------------------------------
	"Effect"ë¥¼ ì„ ì–¸í•˜ë ¤ë©´, React ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useEffect"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”:

		import { useEffect } from 'react';
		import { createConnection } from './chat.js';


		function ChatRoom({ roomId }) {
			const [serverUrl, setServerUrl] = useState('https://localhost:1234');	<--- ***

			useEffect(() => { 	// "setup" function									<--- ***
				const connection = createConnection(serverUrl, roomId);
				connection.connect();
				
				return () => {	// "cleanup" function
					connection.disconnect();
				}
			}, [serverUrl, roomId]);

			// ...
		}

  â—‹ Parameters

	â‘  setup
		â— The function with your Effectâ€™s logic.
		â— Your "setup" function may also optionally return a "cleanup" function.
		â— When your component is added to the DOM, React will run your "setup" function.
		â— After "every re-render" with changed dependencies,
		  React will first run the "cleanup" function (if you provided it) with the "old" values,
		  and then run your "setup" function with the "new" values.
		â— After your component is removed from the DOM, React will run your "cleanup" function.
  		---------------------------------
		â— Effectì˜ ë¡œì§ì„ ê°–ì¶˜ í•¨ìˆ˜ì…ë‹ˆë‹¤.
		â— "setup" í•¨ìˆ˜ëŠ” ì„ íƒì ìœ¼ë¡œ "cleanup" í•¨ìˆ˜ë¥¼ ë°˜í™˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
		â— ì»´í¬ë„ŒíŠ¸ê°€ DOMì— ì¶”ê°€ë˜ë©´, ReactëŠ” "setup" í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.						<--- ***: â“
		â— ì¢…ì†ì„± ë³€ê²½ìœ¼ë¡œ, "ë§¤ë²ˆ ì¬ë Œë”ë§" í•œ í›„, 
		  ReactëŠ” ë¨¼ì € "ì´ì „" ê°’ì„ ì‚¬ìš©í•˜ì—¬ "cleanup" í•¨ìˆ˜ (ì œê³µí•œ ê²½ìš°)ì„ ì‹¤í–‰í•œ ë‹¤ìŒ,
		  "ìƒˆ" ê°’ì„ ì‚¬ìš©í•˜ì—¬ "setup" í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.										<--- ***: â“‘
		â— ì»´í¬ë„ŒíŠ¸ê°€ DOMì—ì„œ ì œê±°ëœ í›„, ReactëŠ” "cleanup" í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.				<--- ***: â“’

	â‘¡ optional dependencies
		â— The list of all "reactive" values referenced inside of the "setup code".
		â— "Reactive" values include "props", "state", and all the "variables" and "functions" 
		  declared "directly" inside your "component body".
		â— If your linter is configured for React, it will verify that 
		  "every reactive" value is correctly specified as a dependency.
		â— The list of dependencies must have a constant number of items
		  and be written inline like "[dep1, dep2, dep3]".
		â— React will compare "each dependency" with its "previous value" using the "Object.is" comparison.
		â— If you omit this argument, your Effect will "re-run" after "every re-render" of the component.
  		---------------------------------
		â— "ì„¤ì •ì½”ë“œ" ë‚´ë¶€ì—ì„œ ì°¸ì¡°ë˜ëŠ” ëª¨ë“  "ë°˜ì‘í˜•" ê°’ì˜ ëª©ë¡ì…ë‹ˆë‹¤.
		â— "ë°˜ì‘í˜•" ê°’ì—ëŠ”, â’œ "props" â’ "state" ë° â’ "ì»´í¬ë„ŒíŠ¸ ë³¸ë¬¸" ë‚´ë¶€ì—ì„œ "ì§ì ‘" ì„ ì–¸ëœ
		  ëª¨ë“  "ë³€ìˆ˜" ë° í•¨ìˆ˜"ê°€ í¬í•¨ë©ë‹ˆë‹¤.
		â— Linterê°€ Reactìš©ìœ¼ë¡œ êµ¬ì„±ëœ ê²½ìš°, "ëª¨ë“  ë°˜ì‘ì„±" ê°’ì´ ì¢…ì†ì„±ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ì§€ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
		â— ì¢…ì†ì„± ëª©ë¡ì€ í•­ëª©ìˆ˜ê°€ ì¼ì •í•´ì•¼ í•˜ë©°, "[dep1, dep2, dep3]"ì²˜ëŸ¼ ì¸ë¼ì¸ìœ¼ë¡œ ì‘ì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
		â— ReactëŠ” "Object.is" ë¹„êµë¥¼ ì‚¬ìš©í•˜ì—¬, "ê° ì¢…ì†ì„±"ì„ "ì´ì „ ê°’"ê³¼ ë¹„êµí•©ë‹ˆë‹¤.
		â— ì´ ì¸ìë¥¼ ìƒëµí•˜ë©´, ì»´í¬ë„ŒíŠ¸ê°€ "ì¬ë Œë”ë§ ë  ë•Œë§ˆë‹¤", íš¨ê³¼ê°€ "ë‹¤ì‹œ ì‹¤í–‰"ë©ë‹ˆë‹¤.	<--- ***: â““

  â—‹ Returns
	- "useEffect" returns "undefined".

  â—‹ Caveats

	- "useEffect" is a Hook, so you can only call it at the top level of your component or your own Hooks.
	  You canâ€™t call it inside "loops" or "conditions".
	  If you need that, extract a "new component" and move the "state" into it.
	  ---------------------------------
	  "useEffect"ëŠ” Hookì´ë¯€ë¡œ, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì´ë‚˜, ìì²´ Hookì—ì„œë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  "ë£¨í”„"ë‚˜ "ì¡°ê±´" ë‚´ì—ì„œëŠ” í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
	  í•„ìš”í•œ ê²½ìš°, "ìƒˆ ì»´í¬ë„ŒíŠ¸"ë¥¼ ì¶”ì¶œí•˜ê³ , "ìƒíƒœ"ë¥¼ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¡œ ì˜®ê¹ë‹ˆë‹¤.

	- If youâ€™re not trying to "synchronize with some external system", you probably donâ€™t need an "Effect".
	  ---------------------------------
	  "ì¼ë¶€ ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ ë™ê¸°í™”"í•˜ë ¤ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ë©´, ì•„ë§ˆë„ "íš¨ê³¼"ê°€ í•„ìš”í•˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤.

	- When Strict Mode is on, React will run one extra "development-only setup + cleanup cycle" 
	  "before" the "first" real setup.
	  This is a stress-test that ensures that your "cleanup logic" â€œmirrorsâ€ your setup logic 
	  and that it stops or undoes whatever the setup is doing.
	  If this causes a problem, implement the "cleanup" function.
	  ---------------------------------
	  Strict ëª¨ë“œê°€ ì¼œì ¸ ìˆìœ¼ë©´, ReactëŠ”, "ì²«ë²ˆì§¸" ì‹¤ì œ ì„¤ì • "ì „ì—", ì¶”ê°€ "ê°œë°œì „ìš© ì„¤ì •+ì •ë¦¬ ì£¼ê¸°"ë¥¼ í•œë²ˆ ì‹¤í–‰í•©ë‹ˆë‹¤.
	  ì´ëŠ” "ì •ë¦¬ë…¼ë¦¬"ê°€ ì„¤ì •ë…¼ë¦¬ë¥¼ "ë¯¸ëŸ¬ë§"í•˜ê³ , 
	  ì„¤ì •ì´ ìˆ˜í–‰í•˜ëŠ” ëª¨ë“  ì‘ì—…ì„ ì¤‘ì§€í•˜ê±°ë‚˜ ì‹¤í–‰ì·¨ì†Œí•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.
	  ì´ë¡œ ì¸í•´ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ” ê²½ìš°, "cleanup" í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì‹­ì‹œì˜¤.

	- If some of your dependencies are "objects" or "functions" defined inside the component,
	  there is a risk that they will cause the "Effect" to "re-run" more often than needed.

	  To fix this, remove "unnecessary" object and function dependencies.
	  You can also extract state updates and non-reactive logic outside of your Effect.
	  ---------------------------------
	  ì¢…ì†ì„± ì¤‘ ì¼ë¶€ê°€ ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì— ì •ì˜ëœ "ê°ì²´" ë˜ëŠ” "í•¨ìˆ˜"ì¸ ê²½ìš°, 
	  "íš¨ê³¼"ê°€ í•„ìš”í•œ ê²ƒë³´ë‹¤ ë” ìì£¼ "ì¬ì‹¤í–‰"ë  ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤.

	  ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´, "ë¶ˆí•„ìš”í•œ" ê°œì²´ ë° í•¨ìˆ˜ ì¢…ì†ì„±ì„ ì œê±°í•˜ì„¸ìš”.
	  Effect ì™¸ë¶€ì—ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ì™€ ë¹„ë°˜ì‘í˜• ë¡œì§ì„ ì¶”ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

	- If your Effect wasnâ€™t caused by an interaction (like a click), 
	  React will generally let the browser paint the updated screen first before running your Effect.

	  If your Effect is doing something visual (for example, positioning a tooltip), 
	  and the delay is noticeable (for example, it flickers), replace "useEffect" with "useLayoutEffect".
	  ---------------------------------
	  Effectê°€ ìƒí˜¸ì‘ìš©(ì˜ˆ: í´ë¦­)ìœ¼ë¡œ ì¸í•´ ë°œìƒí•˜ì§€ ì•ŠëŠ”ê²½ìš°,
	  ReactëŠ”, ì¼ë°˜ì ìœ¼ë¡œ Effectë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì—, ë¸Œë¼ìš°ì €ê°€ ì—…ë°ì´íŠ¸ëœ í™”ë©´ì„ ë¨¼ì € ê·¸ë¦¬ë„ë¡ í•©ë‹ˆë‹¤.

	  íš¨ê³¼ê°€ ì‹œê°ì ì¸ ì‘ì—…(ì˜ˆ: ë„êµ¬ ì„¤ëª… ìœ„ì¹˜ ì§€ì •)ì„ ìˆ˜í–‰í•˜ê³ , ì§€ì—°ì´ ëˆˆì— ë„ëŠ” ê²½ìš°(ì˜ˆ: ê¹œë°•ì„), 
	  "useEffect"ë¥¼ "useLayoutEffect"ë¡œ ë°”ê¾¸ì„¸ìš”.

	- Even if your Effect was caused by an interaction (like a click),
	  the browser may repaint the screen before processing the state updates inside your Effect.
	  
	  Usually, thatâ€™s what you want.
	  However, if you must block the browser from repainting the screen, 
	  you need to replace "useEffect" with "useLayoutEffect".
	  ---------------------------------
	  Effectê°€ ìƒí˜¸ì‘ìš©(ì˜ˆ: í´ë¦­)ìœ¼ë¡œ ì¸í•´ ë°œìƒí•œ ê²½ìš°ì—ë„,
	  ë¸Œë¼ìš°ì €ëŠ”, Effect ë‚´ë¶€ì˜ ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê¸° ì „ì—, í™”ë©´ì„ ë‹¤ì‹œ ì¹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	  ì¼ë°˜ì ìœ¼ë¡œ ê·¸ê²ƒì´ ë‹¹ì‹ ì´ ì›í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
	  ê·¸ëŸ¬ë‚˜, ë¸Œë¼ìš°ì €ê°€ í™”ë©´ì„ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” ê²ƒì„ ì°¨ë‹¨í•´ì•¼ í•˜ëŠ”ê²½ìš°,
	  "useEffect"ë¥¼ "useLayoutEffect"ë¡œ ë°”ê¿”ì•¼ í•©ë‹ˆë‹¤.

	- Effects only run on the client.
	  They donâ€™t run during server rendering.
	  ---------------------------------
	  íš¨ê³¼ëŠ” í´ë¼ì´ì–¸íŠ¸ì—ì„œë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤.
	  ì„œë²„ ë Œë”ë§ ì¤‘ì—ëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

â–  Usage #1	- Connecting to an external system

  â—‹ Some components need to stay connected to the network, some browser API, or a third-party library, 
	while they are displayed on the page.
	These systems arenâ€™t controlled by React, so they are called external.

	To connect your component to some external system, call useEffect at the top level of your component:
	---------------------------------
	ì¼ë¶€ ì»´í¬ë„ŒíŠ¸ëŠ” í˜ì´ì§€ì— í‘œì‹œë˜ëŠ” ë™ì•ˆ, ë„¤íŠ¸ì›Œí¬, ì¼ë¶€ ë¸Œë¼ìš°ì € API ë˜ëŠ” íƒ€ì‚¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ê³„ì† ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
	ì´ëŸ¬í•œ ì‹œìŠ¤í…œì€ Reactì— ì˜í•´ ì œì–´ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì™¸ë¶€ë¼ê³  í•©ë‹ˆë‹¤.

	ì»´í¬ë„ŒíŠ¸ë¥¼ ì™¸ë¶€ ì‹œìŠ¤í…œì— ì—°ê²°í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useEffect"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.

		import { useEffect } from 'react';
		import { createConnection } from './chat.js';

		function ChatRoom({ roomId }) {
			const [serverUrl, setServerUrl] = useState('https://localhost:1234');		<--- ***

			useEffect(() => {															<--- ***
				const connection = createConnection(serverUrl, roomId);
				connection.connect();

				return () => {
					connection.disconnect();
				};
			}, [serverUrl, roomId]);													<--- ***

			// ...
		}

  â—‹ You need to pass two arguments to "useEffect" :

	â‘  A setup function with setup code that connects to that system.
	   It should return a cleanup function with cleanup code that disconnects from that system.
	â‘¡ A list of dependencies including every value from your component used inside of those functions.
	---------------------------------
	"useEffect"ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´, ë‘ ê°œì˜ ì¸ìë¥¼ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤ :

	â‘  í•´ë‹¹ ì‹œìŠ¤í…œì— ì—°ê²°ë˜ëŠ” ì„¤ì •ì½”ë“œê°€ ìˆëŠ” ì„¤ì •í•¨ìˆ˜ ì…ë‹ˆë‹¤.
	   í•´ë‹¹ ì‹œìŠ¤í…œê³¼ì˜ ì—°ê²°ì„ ëŠëŠ” ì •ë¦¬ì½”ë“œê°€ í¬í•¨ëœ ì •ë¦¬í•¨ìˆ˜ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
	â‘¡ í•´ë‹¹ í•¨ìˆ˜ ë‚´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì»´í¬ë„ŒíŠ¸ì˜ ëª¨ë“  ê°’ì„ í¬í•¨í•œ ì¢…ì†ì„± ëª©ë¡ì…ë‹ˆë‹¤.

  â—‹ React calls your setup and cleanup functions whenever itâ€™s necessary, which may happen multiple times:

	â‘  Your setup code runs when your component is added to the page (mounts).
	â‘¡ After every re-render of your component where the dependencies have changed:
	   â— First, your cleanup code runs with the old props and state.
	   â— Then, your setup code runs with the new props and state.
	â‘¢ Your cleanup code runs one final time after your component is removed from the page (unmounts).
	  ---------------------------------
	ReactëŠ” í•„ìš”í•  ë•Œë§ˆë‹¤ ì„¤ì • ë° ì •ë¦¬ ê¸°ëŠ¥ì„ í˜¸ì¶œí•˜ë©°, ì´ëŠ” ì—¬ëŸ¬ ë²ˆ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ :

	â‘  í˜ì´ì§€ì— ì»´í¬ë„ŒíŠ¸ë¥¼ ì¶”ê°€(ë§ˆìš´íŠ¸)í•  ë•Œ, ì„¤ì •ì½”ë“œê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
	â‘¡ ì¢…ì†ì„±ì´ ë³€ê²½ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•  ë•Œë§ˆë‹¤, ë‹¤ìŒì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
	   â— ì²«ì§¸, ì •ë¦¬ì½”ë“œëŠ” ì´ì „ props ë° stateë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰ë©ë‹ˆë‹¤.
	   â— ê·¸ëŸ¬ë©´ ì„¤ì •ì½”ë“œê°€ ìƒˆë¡œìš´ props ë° stateì™€ í•¨ê»˜ ì‹¤í–‰ë©ë‹ˆë‹¤.
	â‘¢ ì»´í¬ë„ŒíŠ¸ê°€ í˜ì´ì§€ì—ì„œ ì œê±°(ë§ˆìš´íŠ¸í•´ì œ)ëœ í›„, ì •ë¦¬ì½”ë“œê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ í•œë²ˆ ì‹¤í–‰ë©ë‹ˆë‹¤.

  â—‹ Letâ€™s illustrate this sequence for the example above:

	â— When the ChatRoom component above gets added to the page, 
	  it will connect to the chat room with the initial serverUrl and roomId.
	â— If either serverUrl or roomId change as a result of a re-render
	  (say, if the user picks a different chat room in a dropdown),
	  your Effect will disconnect from the previous room, and connect to the next one.
	â— When the ChatRoom component is removed from the page, your Effect will disconnect one last time.
	---------------------------------
	ìœ„ì˜ ì˜ˆì—ì„œ ì´ ìˆœì„œë¥¼ ì„¤ëª…í•´ ë³´ê² ìŠµë‹ˆë‹¤ :

	â— ìœ„ì˜ ChatRoom ì»´í¬ë„ŒíŠ¸ê°€ í˜ì´ì§€ì— ì¶”ê°€ë˜ë©´ ì´ˆê¸° serverUrl ë° roomIdë¡œ ì±„íŒ…ë°©ì— ì—°ê²°ë©ë‹ˆë‹¤.
	â— ì¬ë Œë”ë§ì˜ ê²°ê³¼ë¡œ serverUrl ë˜ëŠ” roomIdê°€ ë³€ê²½ë˜ëŠ” ê²½ìš° (ì˜ˆ: ì‚¬ìš©ìê°€ ë“œë¡­ë‹¤ìš´ì—ì„œ ë‹¤ë¥¸ ì±„íŒ…ë°©ì„ ì„ íƒí•˜ëŠ” ê²½ìš°),
	  íš¨ê³¼ëŠ” ì´ì „ ë°©ê³¼ì˜ ì—°ê²°ì´ ëŠì–´ì§€ê³  ë‹¤ìŒ ë°©ì— ì—°ê²°ë©ë‹ˆë‹¤.
	â— ChatRoom ì»´í¬ë„ŒíŠ¸ê°€ í˜ì´ì§€ì—ì„œ ì œê±°ë˜ë©´ ë§ˆì§€ë§‰ìœ¼ë¡œ Effectì˜ ì—°ê²°ì´ ëŠì–´ì§‘ë‹ˆë‹¤.

  â—‹ To help you find bugs, in development React runs setup and cleanup one extra time before the setup.
	This is a stress-test that verifies your Effectâ€™s logic is implemented correctly.
	If this causes visible issues, your cleanup function is missing some logic.
	The cleanup function should stop or undo whatever the setup function was doing.
	The rule of thumb is that the user shouldnâ€™t be able to distinguish between the setup being called once (as in production)
	and a setup â†’ cleanup â†’ setup sequence (as in development).
	---------------------------------
	ë²„ê·¸ë¥¼ ì°¾ëŠ” ë° ë„ì›€ì„ ì£¼ê¸° ìœ„í•´, ê°œë°œë‹¨ê³„ì—ì„œ ReactëŠ” ì„¤ì • ì „ì— í•œë²ˆ ë” ì„¤ì • ë° ì •ë¦¬ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
	ì´ëŠ” Effectì˜ ë¡œì§ì´ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.
	ì´ë¡œì¸í•´, ëˆˆì— ë„ëŠ” ë¬¸ì œê°€ ë°œìƒí•˜ë©´, ì •ë¦¬ í•¨ìˆ˜ì— ì¼ë¶€ ë…¼ë¦¬ê°€ ëˆ„ë½ëœ ê²ƒì…ë‹ˆë‹¤.
	ì •ë¦¬ í•¨ìˆ˜ëŠ” ì„¤ì • í•¨ìˆ˜ê°€ ìˆ˜í–‰í•˜ë˜ ëª¨ë“  ì‘ì—…ì„ ì¤‘ì§€í•˜ê±°ë‚˜ ì‹¤í–‰ ì·¨ì†Œí•´ì•¼ í•©ë‹ˆë‹¤.
	ê²½í—˜ìƒ ì‚¬ìš©ìëŠ” í•œë²ˆ í˜¸ì¶œë˜ëŠ” ì„¤ì •(í”„ë¡œë•ì…˜ì—ì„œì™€ ê°™ì´)ê³¼ ì„¤ì • â†’ ì •ë¦¬ â†’ ì„¤ì • ìˆœì„œ(ê°œë°œì—ì„œì™€ ê°™ì´)ë¥¼ êµ¬ë³„í•  ìˆ˜ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤.

  â—‹ Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time.
	It shouldnâ€™t matter whether your component is mounting, updating, or unmounting.
	When your cleanup logic correctly â€œmirrorsâ€ the setup logic, 
	your Effect is resilient to running setup and cleanup as often as needed.
	---------------------------------
	ëª¨ë“  Effectë¥¼ ë…ë¦½ì ì¸ í”„ë¡œì„¸ìŠ¤ë¡œ ì‘ì„±í•˜ê³  í•œ ë²ˆì— ë‹¨ì¼ ì„¤ì •/ì •ë¦¬ ì£¼ê¸°ë¥¼ ìƒê°í•´ ë³´ì‹­ì‹œì˜¤.
	ì»´í¬ë„ŒíŠ¸ê°€ ë§ˆìš´íŠ¸, ì—…ë°ì´íŠ¸ ë˜ëŠ” ë§ˆìš´íŠ¸ í•´ì œ ì¤‘ì¸ì§€ëŠ” ì¤‘ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	ì •ë¦¬ ë…¼ë¦¬ê°€ ì„¤ì • ë…¼ë¦¬ë¥¼ ì˜¬ë°”ë¥´ê²Œ "ë¯¸ëŸ¬ë§"í•˜ë©´ EffectëŠ” í•„ìš”í•œ ë§Œí¼ ìì£¼ ì„¤ì • ë° ì •ë¦¬ë¥¼ ì‹¤í–‰í•˜ëŠ” ë° íƒ„ë ¥ì„±ì„ ê°–ìŠµë‹ˆë‹¤.

  â—‹ Note :

	An Effect lets you keep your component synchronized with some external system (like a chat service).

	Here, external system means any piece of code thatâ€™s not controlled by React, such as:
		â— A timer managed with setInterval() and clearInterval().
		â— An event subscription using window.addEventListener() and window.removeEventListener().
		â— A third-party animation library with an API like animation.start() and animation.reset().

	If youâ€™re not connecting to any external system, you probably donâ€™t need an Effect.
	---------------------------------
	Effectë¥¼ ì‚¬ìš©í•˜ë©´ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¼ë¶€ ì™¸ë¶€ ì‹œìŠ¤í…œ(ì˜ˆ: ì±„íŒ… ì„œë¹„ìŠ¤)ê³¼ ë™ê¸°í™”ëœ ìƒíƒœë¡œ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	ì—¬ê¸°ì„œ, ì™¸ë¶€ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì´ Reactì— ì˜í•´ ì œì–´ë˜ì§€ ì•ŠëŠ” ì½”ë“œ ì¡°ê°ì„ ì˜ë¯¸í•©ë‹ˆë‹¤ :
		â— setInterval(),clearInterval()ë¡œ ê´€ë¦¬ë˜ëŠ” íƒ€ì´ë¨¸.
		â— window.addEventListener() ë° window.removeEventListener()ë¥¼ ì‚¬ìš©í•œ ì´ë²¤íŠ¸ êµ¬ë….
		â— animation.start() ë° animation.reset()ê³¼ ê°™ì€ APIë¥¼ ê°–ì¶˜ íƒ€ì‚¬ ì• ë‹ˆë©”ì´ì…˜ ë¼ì´ë¸ŒëŸ¬ë¦¬.

	ì™¸ë¶€ ì‹œìŠ¤í…œì— ì—°ê²°í•˜ì§€ ì•ŠëŠ” ê²½ìš°, íš¨ê³¼ê°€ í•„ìš”í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


---------------------------------
06. useId
---------------------------------

â–  The "useId" is a React Hook for generating unique IDs that can be passed to accessibility attributes.
	(ì ‘ê·¼ì„± ì†ì„±ì— ì „ë‹¬ë  ìˆ˜ ìˆëŠ” ê³ ìœ í•œ IDë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ React Hook)

	const id = useId()


â–  Example

	import { useId } from 'react';

	function PasswordField() {
		const passwordHintId = useId();

		// ...


---------------------------------
07. useImperativeHandle
---------------------------------

â–  The "useImperativeHandle" is a React Hook that lets you customize the handle exposed as a "ref".
	("ref"ë¡œ ë…¸ì¶œëœ í•¸ë“¤ì„ ì»¤ìŠ¤í„°ë§ˆì´ì§• í•´ì£¼ëŠ” React Hook)

	useImperativeHandle(ref, createHandle, dependencies?)


â–  Example

	import { forwardRef, useImperativeHandle } from 'react';

	const MyInput = forwardRef(function MyInput(props, ref) {		<--- ***
		useImperativeHandle(ref, () => {							<--- ***
			return {
				// ... your methods ...
			};
		}, []);

		// ...


---------------------------------
08. useInsertionEffect
---------------------------------

â–  The "useInsertionEffect" allows inserting elements into the DOM before any layout effects fire.
	(ë ˆì´ì•„ì›ƒ íš¨ê³¼ê°€ ì‹¤í–‰ë˜ê¸° ì „ì—, DOMì— ìš”ì†Œë¥¼ ì‚½ì…í•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” React Hook)

	useInsertionEffect(setup, dependencies?)


â–  Example

	import { useInsertionEffect } from 'react';

	// Inside your CSS-in-JS library
	function useCSS(rule) {
		useInsertionEffect(() => {
			// ... inject <style> tags here ...
		});

		return rule;
	}


---------------------------------
09. useLayoutEffect
---------------------------------

â–  The "useLayoutEffect" is a version of "useEffect" that fires before the browser repaints the screen.
	(ë¸Œë¼ìš°ì €ê°€ í™”ë©´ì„ ë‹¤ì‹œ ê·¸ë¦¬ê¸° ì „ì—, ì‹¤í–‰ë˜ëŠ” "useEffect" ë²„ì „)

	useLayoutEffect(setup, dependencies?)


â–  Example

	import { useState, useRef, useLayoutEffect } from 'react';

	function Tooltip() {
		const ref = useRef(null);
		const [tooltipHeight, setTooltipHeight] = useState(0);

		useLayoutEffect(() => {
			const { height } = ref.current.getBoundingClientRect();
			setTooltipHeight(height);
		}, []);

		// ...


---------------------------------
10. useMemo
---------------------------------

â–  useMemo(calculateValue, dependencies)


â–  The "useMemo" is a React Hook that lets you cache the result of a calculation between "re-renders".	<--- ***: â“
	----------------------------------------------
  ì¬ë Œë”ë§ ê°„ì—, ì—°ì‚°ê²°ê³¼ë¥¼ ìºì‹œí•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” React Hook.

	const cachedValue = useMemo(calculateValue, dependencies)


â–  Reference

  â—‹ Call "useMemo" at the top level of your component to cache a calculation between re-renders
	----------------------------------------------
	ì¬ë Œë”ë§ ê°„ì˜ ê³„ì‚°ì„ ìºì‹œí•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ, "useMemo"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.
    
  â—‹ Example:

		import { useMemo } from 'react';

		function TodoList({ todos, tab }) {
			const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] );

			// ...
		}
	
  â—‹ Parameters

	â‘  calculateValue
	   	â— The function calculating the value that you want to cache.
	   	â— It should be pure, should take no arguments, and should return a value of any type.
	   	â— React will call your function during the initial render.
	   	â— On next renders, React will return the same value again
	      if the dependencies have not changed since the last render.
	   	â— Otherwise, it will call "calculateValue", return its result, 
		  and store it so it can be reused later.
		----------------------------------------------
		â— ìºì‹œí•˜ë ¤ëŠ” ê°’ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
		â— ìˆœìˆ˜í•´ì•¼ í•˜ê³ , ì¸ìë¥¼ ì·¨í•˜ì§€ ì•Šì•„ì•¼ í•˜ë©°, ëª¨ë“  ìœ í˜•ì˜ ê°’ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
		â— ReactëŠ”, ì´ˆê¸° ë Œë”ë§ ì¤‘ì—, í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.												<--- ***: â“‘
		â— ë§ˆì§€ë§‰ ë Œë”ë§ ì´í›„, ì¢…ì†ì„±ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°,  
		  ë‹¤ìŒ ë Œë”ë§ì—ì„œ ReactëŠ” ë™ì¼í•œ ê°’ì„ ë‹¤ì‹œ ë°˜í™˜í•©ë‹ˆë‹¤.										<--- ***: â“’
		â— ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, "calculateValue"ì„ í˜¸ì¶œí•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•œ í›„, 
		  ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì €ì¥í•©ë‹ˆë‹¤.													<--- ***: â““

	â‘¡ dependencies
	   	â— The list of all reactive values referenced inside of the "calculateValue" code.
	   	â— Reactive values include "props", "state", and "all the variables" and "functions"
	      declared directly inside your component body.
	   	â— If your linter is configured for React,
	      it will verify that every reactive value is correctly specified as a dependency.
	   	â— The list of dependencies must have a constant number of items
	      and be written inline like "[dep1, dep2, dep3]".
	   	â— React will compare each dependency with its previous value 
	      using the "Object.is" comparison.
		----------------------------------------------
		â— "calculateValue" ì½”ë“œ ë‚´ë¶€ì—ì„œ ì°¸ì¡°ë˜ëŠ” ëª¨ë“  ë°˜ì‘í˜• ê°’ì˜ ëª©ë¡ì…ë‹ˆë‹¤.
		â— ë°˜ì‘í˜• ê°’ì—ëŠ” â“ "props" â“‘ "state" â“’ ëª¨ë“  "ë³€ìˆ˜" ë° â““ "í•¨ìˆ˜"ê°€ í¬í•¨ë©ë‹ˆë‹¤.				<--- ***: â“”
		â— linter ê°€ React ìš©ìœ¼ë¡œ êµ¬ì„±ëœ ê²½ìš°, ëª¨ë“  ë°˜ì‘ê°’ì´ ì¢…ì†ì„±ìœ¼ë¡œ ì˜¬ë°”ë¥´ê²Œ ì§€ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
		â— ì¢…ì†ì„± ëª©ë¡ì€ í•­ëª©ìˆ˜ê°€ ì¼ì •í•´ì•¼ í•˜ë©°, "[dep1, dep2, dep3]"ì²˜ëŸ¼ ì¸ë¼ì¸ìœ¼ë¡œ ì‘ì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
		â— ReactëŠ” "Object.is" ë¹„êµë¥¼ ì‚¬ìš©í•˜ì—¬, ê° ì¢…ì†ì„±ì„ ì´ì „ê°’ê³¼ ë¹„êµí•©ë‹ˆë‹¤.
	
  â—‹ Returns

	- On the "initial" render, "useMemo" returns the result of calling "calculateValue" with no arguments.
	- During "next" renders, it will either return an already stored value from the last render
	  (if the dependencies havenâ€™t changed), or call "calculateValue" again,
	  and return the result that "calculateValue" has returned.
	----------------------------------------------
	- ì´ˆê¸° ë Œë”ë§ì—ì„œ, "useMemo"ëŠ” ì¸ìì—†ì´ "calculateValue"ì„ í˜¸ì¶œí•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.			<--- ***: â“•
	- ë‹¤ìŒ ë Œë”ë§ ì¤‘ì—ëŠ”, ë§ˆì§€ë§‰ ë Œë”ë§ì—ì„œ ì´ë¯¸ ì €ì¥ëœ ê°’ì„ ë°˜í™˜í•˜ê±°ë‚˜(ì¢…ì†ì„±ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°),
	  "calculateValue"ì„ ë‹¤ì‹œ í˜¸ì¶œí•˜ê³ , ê³„ì‚°ê°’ì´ ë°˜í™˜í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.							<--- ***: â“–
	
  â—‹ Caveats (ì£¼ì˜ì‚¬í•­)
	- "useMemo" is a Hook, so you can only call it at the top level of your component or your own Hooks.
	  You canâ€™t call it inside loops or conditions.
	  If you need that, extract a new component and move the state into it.
	  ----------------------------------------------
	  "useMemo"ëŠ” Hookì´ë¯€ë¡œ, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì´ë‚˜ ìì²´ Hookì—ì„œë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  ë£¨í”„ë‚˜ ì¡°ê±´ ë‚´ì—ì„œëŠ” í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
	  í•„ìš”í•œ ê²½ìš°, ìƒˆ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìƒíƒœë¥¼ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¡œ ì˜®ê¹ë‹ˆë‹¤.

	- In Strict Mode, React will call your calculation function *TWICE* in order to help you find accidental impurities.
	  This is development-only behavior and does not affect production.
	  If your calculation function is pure (as it should be), this should not affect your logic.
	  The result from one of the calls will be ignored.
	  ----------------------------------------------
	  ì—„ê²©ëª¨ë“œì—ì„œ, ReactëŠ” ìš°ë°œì ì¸ ë¶ˆìˆœë¬¼ì„ ì°¾ëŠ” ë° ë„ì›€ì„ ì£¼ê¸°ìœ„í•´, ê³„ì‚°í•¨ìˆ˜ë¥¼ *ë‘ë²ˆ* í˜¸ì¶œí•©ë‹ˆë‹¤.
	  ì´ëŠ” ê°œë°œì „ìš©ë™ì‘ì´ë©°, í”„ë¡œë•ì…˜ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
	  ê³„ì‚°í•¨ìˆ˜ê°€ ìˆœìˆ˜í•˜ë‹¤ë©´(ë˜ì–´ì•¼ í•˜ëŠ” ëŒ€ë¡œ), ë…¼ë¦¬ì— ì˜í–¥ì„ ì£¼ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
	  í˜¸ì¶œ ì¤‘ í•˜ë‚˜ì˜ ê²°ê³¼ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤.

	- React will not throw away the cached value unless there is a specific reason to do that.
	  For example, in development, React throws away the cache when you edit the file of your component.
	  Both in development and in production, React will throw away the cache
	  if your component suspends during the initial mount.

	  In the future, React may add more features that take advantage of throwing away the cache
	  â€”for example, if React adds built-in support for virtualized lists in the future,
	   it would make sense to throw away the cache for items that scroll out of the virtualized table viewport.

	  This should be fine if you rely on useMemo solely as a performance optimization.
	  Otherwise, a state variable or a ref may be more appropriate.
	----------------------------------------------
	  ReactëŠ”, íŠ¹ë³„í•œ ì´ìœ ê°€ ì—†ëŠ” í•œ, ìºì‹œëœ ê°’ì„ ë²„ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.
	  ì˜ˆë¥¼ ë“¤ì–´, ê°œë°œ ì¤‘ì— ReactëŠ” ì»´í¬ë„ŒíŠ¸ì˜ íŒŒì¼ì„ í¸ì§‘í•  ë•Œ, ìºì‹œë¥¼ ë²„ë¦½ë‹ˆë‹¤.					<--- ***: â“–
	  ê°œë°œê³¼ í”„ë¡œë•ì…˜ ëª¨ë‘ì—ì„œ, ReactëŠ” ì´ˆê¸° ë§ˆìš´íŠ¸ ì¤‘ì—, ì»´í¬ë„ŒíŠ¸ê°€ ì¼ì‹œì¤‘ì§€ë˜ë©´, ìºì‹œë¥¼ ë²„ë¦½ë‹ˆë‹¤.	<--- ***: â“—
	  ì•ìœ¼ë¡œ, ReactëŠ” ìºì‹œë¥¼ ë²„ë¦¬ëŠ” ì´ì ì„ í™œìš©í•˜ëŠ” ë” ë§ì€ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  ì˜ˆë¥¼ë“¤ì–´, Reactê°€ í–¥í›„ì— ê°€ìƒí™”ëœ ëª©ë¡ì— ëŒ€í•œ ê¸°ë³¸ì§€ì›ì„ ì¶”ê°€í•œë‹¤ë©´,
	  ê°€ìƒí™”ëœ í…Œì´ë¸” ë·°í¬íŠ¸ ë°–ìœ¼ë¡œ ìŠ¤í¬ë¡¤ë˜ëŠ” í•­ëª©ì— ëŒ€í•œ ìºì‹œë¥¼ ë²„ë¦¬ëŠ” ê²ƒì´ í•©ë¦¬ì ì¼ ê²ƒì…ë‹ˆë‹¤.
	  ì„±ëŠ¥ìµœì í™” ëª©ì ìœ¼ë¡œë§Œ "useMemo"ë¥¼ ì‚¬ìš©í•œë‹¤ë©´ ê´œì°®ì„ ê²ƒì…ë‹ˆë‹¤.
	  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, "ìƒíƒœë³€ìˆ˜"ë‚˜ "ref"ê°€ ë” ì ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


â–  Note

  Caching return values like this is also known as "memoization",
  this is why this Hook is called "useMemo".
	----------------------------------------------
  ì´ì™€ ê°™ì´ ë°˜í™˜ê°’ì„ ìºì‹±í•˜ëŠ” ê²ƒì„ "ë©”ëª¨ì´ì œì´ì…˜"(memoization)ì´ë¼ê³ ë„ í•˜ë©°,		
  ì´ê²ƒì´ ë°”ë¡œ ì´ Hookì„ "useMemo" ë¼ê³  ë¶€ë¥´ëŠ” ì´ìœ ì…ë‹ˆë‹¤.											<--- ***: â“˜


â–  Usage #1 - Skipping expensive recalculations 

  â—‹ To cache a calculation between re-renders,
  	wrap it in a "useMemo" call at the top level of your component:
	----------------------------------------------
	ì¬ë Œë”ë§í•  ë•Œë§ˆë‹¤ ê³„ì‚°ì„ ìºì‹œí•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useMemo" í˜¸ì¶œë¡œ, ì´ë¥¼ ë˜í•‘í•˜ì„¸ìš”.

	Example:

		import { useMemo } from 'react';

		function TodoList({ todos, tab, theme }) {
			const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
			// ...
		}

  â—‹ You need to pass two things to "useMemo":

	1. A "calculation" function that takes no arguments, like "() =>", and returns what you wanted to calculate.
	2. A list of dependencies including every value within your component thatâ€™s used inside your calculation.
	----------------------------------------------
	1. "() =>" ì™€ ê°™ì´, ì¸ìë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ê³„ì‚°í•˜ë ¤ëŠ” ë‚´ìš©ì„ ë°˜í™˜í•˜ëŠ” ê³„ì‚°í•¨ìˆ˜ì…ë‹ˆë‹¤.
	2. ê³„ì‚° ë‚´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì»´í¬ë„ŒíŠ¸ ë‚´ì˜ ëª¨ë“  ê°’ì„ í¬í•¨í•œ ì¢…ì†ì„± ëª©ë¡ì…ë‹ˆë‹¤.

  â—‹ On the initial render, the value youâ€™ll get from "useMemo" will be the result of calling your calculation.
	----------------------------------------------
	ì´ˆê¸° ë Œë”ë§ ì‹œ, "useMemo"ì—ì„œ ì–»ëŠ” ê°’ì€, ê³„ì‚°ì„ í˜¸ì¶œí•œ ê²°ê³¼ì…ë‹ˆë‹¤.								<--- ***: â“™

	â— On every subsequent render, 
	  React will compare the dependencies with the dependencies you passed during the last render.
	â— If none of the dependencies have changed (compared with Object.is), 
	  "useMemo" will return the value you already calculated before.
	  Otherwise, React will re-run your calculation and return the new value.
	â— In other words, "useMemo" caches a calculation result between re-renders until its dependencies change.
  	---------------------------------
	â— ëª¨ë“  í›„ì† ë Œë”ë§ì—ì„œ, ReactëŠ” ë§ˆì§€ë§‰ ë Œë”ë§ ì¤‘ì— ì „ë‹¬ëœ ì¢…ì†ì„±ê³¼ ì¢…ì†ì„±ì„ ë¹„êµí•©ë‹ˆë‹¤.
	â— ì¢…ì†ì„±ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš° ("Object.is" ì™€ ë¹„êµí•˜ì—¬),
	  "useMemo"ëŠ” ì´ì „ì— ì´ë¯¸ ê³„ì‚°í•œ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ReactëŠ” ê³„ì‚°ì„ ë‹¤ì‹œ ì‹¤í–‰í•˜ê³  ìƒˆ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	â— ì¦‰, "useMemo"ëŠ” ì¢…ì†ì„±ì´ ë³€ê²½ë  ë•Œê¹Œì§€, ì¬ë Œë”ë§ ê°„ì˜ ê³„ì‚°ê²°ê³¼ë¥¼ ìºì‹œí•©ë‹ˆë‹¤.

  â—‹ Letâ€™s walk through an example to see when this is useful.
  	---------------------------------
  	ì´ê²ƒì´ ì–¸ì œ ìœ ìš©í•œì§€ ì•Œì•„ë³´ê¸° ìœ„í•´ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

	By default, React will re-run the entire body of your component every time that it re-renders.

	For example, if this TodoList updates its state or receives new props from its parent,
	the filterTodos function will re-run:
  	---------------------------------
	ê¸°ë³¸ì ìœ¼ë¡œ ReactëŠ”, ì¬ë Œë”ë§ë  ë•Œë§ˆë‹¤, ì»´í¬ë„ŒíŠ¸ì˜ ì „ì²´ë³¸ë¬¸ì„ ë‹¤ì‹œ ì‹¤í–‰í•©ë‹ˆë‹¤.

	ì˜ˆë¥¼ ë“¤ì–´, ì´ TodoListê°€ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ê±°ë‚˜, ìƒìœ„ë¡œë¶€í„° ìƒˆ ì†ì„±ì„ ë°›ìœ¼ë©´,
	filterTodos í•¨ìˆ˜ê°€ ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤:

		function TodoList({ todos, tab, theme }) {
			const visibleTodos = filterTodos(todos, tab);

			// ...
		}

  â—‹ Usually, this isnâ€™t a problem because most calculations are very fast.
    However, if youâ€™re filtering or transforming a large array, or doing some expensive computation,
	you might want to skip doing it again if data hasnâ€™t changed.
	
	If both todos and tab are the same as they were during the last render, 
	wrapping the calculation in "useMemo" like earlier lets you reuse visibleTodos youâ€™ve already calculated before.

	This type of caching is called "memoization".
  	---------------------------------
	ì¼ë°˜ì ìœ¼ë¡œ ëŒ€ë¶€ë¶„ì˜ ê³„ì‚°ì€ ë§¤ìš° ë¹ ë¥´ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	ê·¸ëŸ¬ë‚˜ ëŒ€ê·œëª¨ ë°°ì—´ì„ í•„í„°ë§ ë˜ëŠ” ë³€í™˜í•˜ê±°ë‚˜ ë¹„ìš©ì´ ë§ì´ ë“œëŠ” ê³„ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ê²½ìš°,
	ë°ì´í„°ê°€ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš°, í•´ë‹¹ ì‘ì—…ì„ ë‹¤ì‹œ ê±´ë„ˆë›°ê³  ì‹¶ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
	í•  ì¼ê³¼ íƒ­ì´ ëª¨ë‘ ë§ˆì§€ë§‰ ë Œë”ë§ ë™ì•ˆê³¼ ë™ì¼í•œ ê²½ìš°, ì´ì „ê³¼ ê°™ì´ "useMemo"ë¡œ ê³„ì‚°ì„ ë˜í•‘í•˜ë©´, 
	ì´ì „ì— ì´ë¯¸ ê³„ì‚°í•œ visibleTodoë¥¼ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	ì´ëŸ¬í•œ ìœ í˜•ì˜ ìºì‹±ì„ "ë©”ëª¨ì´ì œì´ì…˜"ì´ë¼ê³  í•©ë‹ˆë‹¤.													<--- ***: â“™

  â—‹ Note

	You should only rely on "useMemo" as a performance optimization.
	If your code doesnâ€™t work without it, find the underlying problem and fix it first.
	Then you may add "useMemo" to improve performance.
  	---------------------------------
	ì„±ëŠ¥ ìµœì í™”ë¡œëŠ” "useMemo"ì—ë§Œ ì˜ì¡´í•´ì•¼ í•©ë‹ˆë‹¤.
	ì½”ë“œê°€ ì—†ìœ¼ë©´, ì½”ë“œê°€ ì‘ë™í•˜ì§€ ì•Šìœ¼ë©´, ê·¼ë³¸ì ì¸ ë¬¸ì œë¥¼ ì°¾ì•„ ë¨¼ì € ìˆ˜ì •í•˜ì„¸ìš”.
	ê·¸ëŸ° ë‹¤ìŒ, ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•´, "useMemo"ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


â–  Usage #2 - Skipping re-rendering of components

  â—‹ In some cases, "useMemo" can also help you optimize performance of re-rendering child components.
  	To illustrate this, letâ€™s say this TodoList component passes the visibleTodos as a prop to the child List component:
  	---------------------------------
	ê²½ìš°ì— ë”°ë¼, "useMemo"ëŠ”, í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ëŠ” ì„±ëŠ¥ì„ ìµœì í™”í•˜ëŠ” ë°, ë„ì›€ì´ ë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
	ì´ë¥¼ ì„¤ëª…í•˜ê¸° ìœ„í•´, ì´ TodoList ì»´í¬ë„ŒíŠ¸ê°€ visibleTodosë¥¼ í•˜ìœ„ List ì»´í¬ë„ŒíŠ¸ì— ì†Œí’ˆìœ¼ë¡œ ì „ë‹¬í•œë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤:

		export default function TodoList({ todos, tab, theme }) {
			// ...
			return (
				<div className={theme}>
					<List items={visibleTodos} />
				</div>
			);
		}

  â—‹ Youâ€™ve noticed that toggling the theme prop freezes the app for a moment,
  	but if you remove <List /> from your JSX, it feels fast.
	This tells you that itâ€™s worth trying to optimize the List component.
  	---------------------------------
	theme propì„ ì „í™˜í•˜ë©´ ì•±ì´ ì ì‹œ ì •ì§€ë˜ì§€ë§Œ, JSXì—ì„œ <List />ë¥¼ ì œê±°í•˜ë©´ ì†ë„ê°€ ë¹¨ë¼ì§€ëŠ” ê²ƒì„ ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	ì´ëŠ” List êµ¬ì„± ìš”ì†Œë¥¼ ìµœì í™”í•´ ë³¼ ê°€ì¹˜ê°€ ìˆìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤.

  â—‹ By default, when a component re-renders, React re-renders all of its children recursively.
    This is why, when TodoList re-renders with a different theme, the List component also re-renders.
	This is fine for components that donâ€™t require much calculation to re-render.
	But if youâ€™ve verified that a re-render is slow, you can tell List to skip re-rendering 
	when its props are the same as on last render by wrapping it in "memo":
  	---------------------------------
	ê¸°ë³¸ì ìœ¼ë¡œ ì»´í¬ë„ŒíŠ¸ê°€ ë‹¤ì‹œ ë Œë”ë§ë˜ë©´, ReactëŠ” ëª¨ë“  í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ë“¤ì„ ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ ë Œë”ë§í•©ë‹ˆë‹¤.	<--- ***: â“š
	ì´ê²ƒì´ TodoListê°€ ë‹¤ë¥¸ í…Œë§ˆë¡œ ë‹¤ì‹œ ë Œë”ë§ë  ë•Œ, List ì»´í¬ë„ŒíŠ¸ë„ ë‹¤ì‹œ ë Œë”ë§ë˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤.

	ì´ëŠ” ë‹¤ì‹œ ë Œë”ë§í•˜ëŠ” ë° ë§ì€ ê³„ì‚°ì´ í•„ìš”í•˜ì§€ ì•Šì€ ì»´í¬ë„ŒíŠ¸ì— ì í•©í•©ë‹ˆë‹¤.
	ê·¸ëŸ¬ë‚˜ ì¬ë Œë”ë§ì´ ëŠë¦¬ë‹¤ëŠ” ê²ƒì„ í™•ì¸í•œ ê²½ìš°, propsê°€ ë§ˆì§€ë§‰ ë Œë”ë§ê³¼ ë™ì¼í•  ë•Œ,
	"memo"ë¡œ ë˜í•‘í•˜ì—¬ Listì— ì¬ë Œë”ë§ì„ ê±´ë„ˆë›°ë„ë¡ ì§€ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

		import { memo } from 'react';

		const List = memo(function List({ items }) {
			// ...
		});

  â—‹ With this change, List will skip re-rendering if all of its props are the same as on the last render.
    This is where caching the calculation becomes important!

	Imagine that you calculated visibleTodos without "useMemo":
  	---------------------------------
	ì´ ë³€ê²½ìœ¼ë¡œ ì¸í•´, ListëŠ” ëª¨ë“  propì´ ë§ˆì§€ë§‰ ë Œë”ë§ê³¼ ë™ì¼í•˜ë©´, ì¬ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤.
	ì—¬ê¸°ì„œ ê³„ì‚° ìºì‹±ì´ ì¤‘ìš”í•´ì§‘ë‹ˆë‹¤! 
	
	"useMemo" ì—†ì´ visibleTodosë¥¼ ê³„ì‚°í–ˆë‹¤ê³  ìƒìƒí•´ ë³´ì„¸ìš”:

		export default function TodoList({ todos, tab, theme }) {
			// Every time the theme changes, this will be a different array...
			const visibleTodos = filterTodos(todos, tab);

			return (
				<div className={theme}>
				{/* ... so List's props will never be the same, and it will re-render every time */}
				<List items={visibleTodos} />
				</div>
			);
		}

  â—‹ In the above example, the filterTodos function always creates a different array, 
  	similar to how the {} object literal always creates a new object.
	Normally, this wouldnâ€™t be a problem, but it means that List props will never be the same, 
	and your memo optimization wonâ€™t work.

  	This is where useMemo comes in handy:
  	---------------------------------
	ìœ„ ì˜ˆì‹œì—ì„œ filterTodos í•¨ìˆ˜ëŠ” í•­ìƒ ë‹¤ë¥¸ ë°°ì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
	ì´ëŠ”, {} ê°ì²´ ë¦¬í„°ëŸ´ì´ í•­ìƒ ìƒˆ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ë°©ì‹ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤.
	ì¼ë°˜ì ìœ¼ë¡œ ì´ëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ, List propsê°€ ê²°ì½” ë™ì¼í•˜ì§€ ì•Šìœ¼ë©°, 
	ë©”ëª¨ ìµœì í™”ê°€ ì‘ë™í•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

	"useMemo"ê°€ ìœ ìš©í•œ ê³³ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

		export default function TodoList({ todos, tab, theme }) {
			// Tell React to cache your calculation between re-renders...
			const visibleTodos = useMemo(
				() => filterTodos(todos, tab),
				[todos, tab] // ...so as long as these dependencies don't change...
			);

			return (
				<div className={theme}>
					{/* ...List will receive the same props and can skip re-rendering */}
					<List items={visibleTodos} />
				</div>
			);
		}

  â—‹ By wrapping the visibleTodos calculation in "useMemo", 
  	you ensure that it has the same value between the re-renders (until dependencies change).
	You donâ€™t have to wrap a calculation in "useMemo" unless you do it for some specific reason.
	In this example, the reason is that you pass it to a component wrapped in "memo", and this lets it skip re-rendering.
  	There are a few other reasons to add "useMemo" which are described further on this page.
  	---------------------------------
	visibleTodos ê³„ì‚°ì„ "useMemo"ë¡œ ë˜í•‘í•˜ë©´, ë‹¤ì‹œ ë Œë”ë§í•  ë•Œ(ì¢…ì†ì„±ì´ ë³€ê²½ë  ë•Œê¹Œì§€) ë™ì¼í•œ ê°’ì„ ê°–ê²Œ ë©ë‹ˆë‹¤.
	íŠ¹ë³„í•œ ì´ìœ ê°€ ì—†ëŠ” í•œ, "useMemo"ì—ì„œ ê³„ì‚°ì„ ë˜í•‘í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤.
	ì´ ì˜ˆì—ì„œ ê·¸ ì´ìœ ëŠ” "ë©”ëª¨"ë¡œ ë˜í•‘ëœ ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬í•˜ì—¬ ë‹¤ì‹œ ë Œë”ë§ì„ ê±´ë„ˆë›¸ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
	ì´ í˜ì´ì§€ì—ì„œ ìì„¸íˆ ì„¤ëª…í•˜ëŠ” "useMemo"ë¥¼ ì¶”ê°€í•˜ëŠ” ëª‡ ê°€ì§€ ë‹¤ë¥¸ ì´ìœ ê°€ ìˆìŠµë‹ˆë‹¤.


---------------------------------
11. useReducer
---------------------------------

                 â‘¡       â‘¢                    â‘ 
               ------  --------              --------  ----------
â–  Usage: const [state, dispatch] = useReducer(reducer, initialArg, init?)			<--- ***: â“


â–  The "useReducer" is a React Hook that lets you add a "reducer" to your component.	<--- ***: â“‘
	(ì»´í¬ë„ŒíŠ¸ì— reducerë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” React Hook)


â–  Reference

  â—‹ Usage:	useReducer(reducer, initialArg, init?)

  â—‹ Call "useReducer" at the top level of your component to manage its "state" with a "reducer":
	----------------------------------
	"reducer"ë¡œ ì»´í¬ë„ŒíŠ¸ì˜ "ìƒíƒœ(state)"ë¥¼ ê´€ë¦¬í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useReducer"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”:


	import { useReducer } from 'react';

					  ***
			 ----------------------
	function reducer(state, action) { â”€â”€â”€â”€â”€â”€â”€â”€â”										<--- ***: â“’
		// ...								  â”‚	
	}										  â”‚
											  â”‚
	function MyComponent() {				  â”‚      "initialArg"
											  â–¼      ------------
		const [state, dispatch] = useReducer(reducer, { age: 42 });					<--- ***: â““

		// ...


â–  Parameters

  â‘  reducer
  	â— The "reducer" function that specifies how the "state" gets updated.
	â— It must be pure, should take the state and action as arguments, and should return the next state.
	â— State and action can be of any types.
	----------------------------------
	â— "ìƒíƒœ"ê°€ ì—…ë°ì´íŠ¸ë˜ëŠ” ë°©ë²•ì„ ì§€ì •í•˜ëŠ” "reducer" í•¨ìˆ˜.												<--- ***: â“”
	â— ìˆœìˆ˜í•´ì•¼ í•˜ë©°, ìƒíƒœ(state)ì™€ ì•¡ì…˜(action)ì„ ì¸ìë¡œ ê°€ì ¸ì™€, ë‹¤ìŒ ìƒíƒœ(state)ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.	<--- ***: â“•
	â— ìƒíƒœ(state)ì™€ ì•¡ì…˜(action)ì€ ëª¨ë“  ìœ í˜•ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  â‘¡ initialArg
    â— The value from which the initial state is calculated.
	â— It can be a value of any type. 
	  How the initial state is calculated from it depends on the next init argument.
	----------------------------------
	â— ì´ˆê¸°ìƒíƒœ(initial state)ê°€ ê³„ì‚°ë˜ëŠ” ê°’ì…ë‹ˆë‹¤.														<--- ***: â“–
	â— ëª¨ë“  ìœ í˜•ì˜ ê°’ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  ì´ˆê¸°ìƒíƒœ(initial state)ê°€ ê³„ì‚°ë˜ëŠ” ë°©ë²•ì€, ë‹¤ìŒ "init" ì¸ìì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤.

  â‘¢ init?
	â— The "initializer" function that should return the "initial state".
	â— If itâ€™s *NOT* specified, the "initial state" is set to "initialArg".
	  Otherwise, the "initial state" is set to the result of calling "init(initialArg)".
	----------------------------------
	â— ì´ˆê¸°ìƒíƒœ(initial state)ë¥¼ ë°˜í™˜í•´ì•¼ í•˜ëŠ” ì´ˆê¸°í™”(initializer) í•¨ìˆ˜ì…ë‹ˆë‹¤.							<--- *** 
	â— ì§€ì •í•˜ì§€ ì•Šì„ ê²½ìš°, ì´ˆê¸°ìƒíƒœëŠ” "initialArg"ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.											<--- *** 
	  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ì´ˆê¸°ìƒíƒœëŠ” "init(initialArg)" í˜¸ì¶œê²°ê³¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.								<--- ***


â–  Returns

  â—‹ "useReducer" returns an "Array" with exactly *two* values:
		1. The *current* state. 																			<--- ***: â“”
		   During the *first* render, itâ€™s set to "init(initialArg)" or "initialArg" (if thereâ€™s no "init").
		2. The "dispatch(action)" function that lets you "update" the state to a different value
		   and "trigger" a re-render.																		<--- ***: â“•
  	----------------------------------
    "useReducer"ëŠ” ì •í™•íˆ ë‘ ê°œì˜ ê°’ì´ ìˆëŠ” ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤:
		1. í˜„ì¬ ìƒíƒœ.																						<--- ***
		   ì²«ë²ˆì§¸ ë Œë”ë§ ì¤‘ì—ëŠ”, "init(initialArg)" ë˜ëŠ” "initialArg" (initê°€ ì—†ëŠ” ê²½ìš°)ë¡œ, ì„¤ì •ë©ë‹ˆë‹¤.
		2. ìƒíƒœë¥¼ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , ì¬ë Œë”ë§ì„ íŠ¸ë¦¬ê±° í•  ìˆ˜ ìˆëŠ” "dispatch(action)" í•¨ìˆ˜.			<--- ***

                 â‘        â‘¡                    
               ------  --------
		const [state, dispatch] = useReducer(reducer, { age: 42 });										<--- ***

		function handleClick() {
			dispatch({ type: 'incremented_age' });														<--- ***

			// ...


â–  Caveats (ì£¼ì˜ì‚¬í•­)

  â—‹ "useReducer" is a Hook, so you can only call it at the top level of your component or your own Hooks.
    You canâ€™t call it inside loops or conditions.
	If you need that, extract a new component and move the "state" into it.
	----------------------------------
  	"useReducer"ëŠ” Hookì´ë¯€ë¡œ, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì´ë‚˜ ìì²´ Hookì—ì„œë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    ë£¨í”„ë‚˜ ì¡°ê±´ ë‚´ì—ì„œëŠ” í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
	í•„ìš”í•œ ê²½ìš°, ìƒˆ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  "ìƒíƒœ"ë¥¼ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¡œ ì˜®ê¹ë‹ˆë‹¤.

  â—‹ In Strict Mode, React will call your reducer and initializer *twice*
    in order to help you find accidental impurities.
    This is development-only behavior and does not affect production.
	If your reducer and initializer are pure (as they should be), this should not affect your logic.
	The result from one of the calls is ignored.
	----------------------------------
  	ì—„ê²©ëª¨ë“œì—ì„œ, ReactëŠ”, ì‹¤ìˆ˜ë¡œ ë°œìƒí•œ ë¶ˆìˆœë¬¼ì„ ì°¾ëŠ” ë° ë„ì›€ì„ ì£¼ê¸° ìœ„í•´,
    reducerì™€ initializerì„ *ë‘ë²ˆ* í˜¸ì¶œí•©ë‹ˆë‹¤.					<--- ***
    ì´ëŠ” ê°œë°œì „ìš© ë™ì‘ì´ë©°, í”„ë¡œë•ì…˜ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
	reducerì™€ initializerê°€ ìˆœìˆ˜(ìˆœìˆ˜í•´ì•¼ í•¨)ì¸ ê²½ìš°, ì´ëŠ” ë…¼ë¦¬ì— ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	í˜¸ì¶œ ì¤‘ í•˜ë‚˜ì˜ ê²°ê³¼ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤.							<--- ***


â–  "dispatch(action)" function											<--- ***

  â—‹ The "dispatch(action)" function returned by "useReducer"
    lets you "update" the "state" to a different value and "trigger" a "re-render".

    You need to pass the "action" as the only argument to the "dispatch" function:
	----------------------------------
  	"useReducer"ì—ì„œ ë°˜í™˜ëœ "dispatch" í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´, 
    ìƒíƒœ(state)ë¥¼ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , ì¬ë Œë”ë§ì„ íŠ¸ë¦¬ê±° í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.	<--- ***

    "dispatch(action)" í•¨ìˆ˜ì— ëŒ€í•œ ìœ ì¼í•œ ì¸ìë¡œ, ì•¡ì…˜(action)ì„ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤:
						***                   ***
					 ---------               -------
		const [state, dispatch] = useReducer(reducer, { age: 42 });				<--- ***

		function handleClick() {

							  "action"
					 --------------------------
			dispatch({ type: 'incremented_age' });								<--- ***

			// ...

  â—‹ React will set the next state to the result of calling the "reducer" function 
    youâ€™ve provided with the "current state" and the "action" youâ€™ve passed to "dispatch".	<--- ***
	----------------------------------
  	ReactëŠ”, "dispatch(action)"ì— ì „ë‹¬í•œ "action"ì™€ "í˜„ì¬ ìƒíƒœ"ë¥¼ ê°€ì§€ê³ ,
    ì œê³µí•œ "reducer" í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ê²°ê³¼ë¡œ, "ë‹¤ìŒ ìƒíƒœ"ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.


â–  Parameters

  â‘  action (ì‘ì—…)
  	â— The "action" performed by the user.
	â— It can be a value of any type.
	â— By convention, an "action" is usually an object with a "type" property identifying it
	  and, optionally, other properties with additional information.
	----------------------------------
	â— ì‚¬ìš©ìê°€ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì…ë‹ˆë‹¤.
	â— ëª¨ë“  ìœ í˜•ì˜ ê°’ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	â— ê´€ë¡€ì ìœ¼ë¡œ "action"ì€ ì¼ë°˜ì ìœ¼ë¡œ, 
	  ì´ë¥¼(action) ì‹ë³„í•˜ëŠ” ìœ í˜•(type) ì†ì„±ê³¼ ì„ íƒì ìœ¼ë¡œ ì¶”ê°€ì •ë³´ê°€ ìˆëŠ” ê¸°íƒ€ì†ì„±ì´ ìˆëŠ” ê°ì²´ì…ë‹ˆë‹¤.


â–  Returns 

  â—‹ "dispatch(action)" functions do *NOT* have a return value.
	----------------------------------
  	"dispatch(action)" í•¨ìˆ˜ì—ëŠ” ë°˜í™˜ ê°’ì´ ì—†ìŠµë‹ˆë‹¤.


â–  Caveats (ì£¼ì˜ì‚¬í•­)

  â—‹ The "dispatch(action)" function *ONLY* updates the "state variable" for the *next* render.
    If you read the "state variable" after calling the "dispatch(action)" function, 
	you will still get the old value that was on the screen before your call.
	----------------------------------
  	"dispatch(action)" í•¨ìˆ˜ëŠ”, ë‹¤ìŒ ë Œë”ë§ì— ëŒ€í•œ ìƒíƒœë³€ìˆ˜ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    "dispatch(action)" í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ í›„ ìƒíƒœë³€ìˆ˜ë¥¼ ì½ìœ¼ë©´, í˜¸ì¶œí•˜ê¸° ì „ì— í™”ë©´ì— ìˆì—ˆë˜ ì´ì „ ê°’ì„ ê³„ì† ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  â—‹ If the new value you provide is identical to the current state, as determined by an "Object.is" comparison,
    React will skip re-rendering the component and its children.

	This is an optimization.

	React may still need to call your component before ignoring the result, 
	but it shouldnâ€™t affect your code.
	----------------------------------
  	ì œê³µí•œ ìƒˆ ê°’ì´ "Object.is" ë¹„êµì— ì˜í•´ ê²°ì •ëœ í˜„ì¬ìƒíƒœì™€ ë™ì¼í•˜ë©´,
    ReactëŠ” ì»´í¬ë„ŒíŠ¸ì™€ ê·¸ í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¬ë Œë”ë§í•˜ëŠ” ê²ƒì„ ê±´ë„ˆëœë‹ˆë‹¤.

    ì´ê²ƒì€ ìµœì í™”ì…ë‹ˆë‹¤.

	ReactëŠ” ê²°ê³¼ë¥¼ ë¬´ì‹œí•˜ê¸° ì „ì—, ì»´í¬ë„ŒíŠ¸ë¥¼ í˜¸ì¶œí•´ì•¼ í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì½”ë“œì— ì˜í–¥ì„ ì£¼ì–´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.

  â—‹ React "batches" state updates.
    It updates the screen after all the event handlers have run and have called their set functions.
	This prevents multiple re-renders during a single event.

	In the rare case that you need to force React to update the screen earlier, 
	for example to access the DOM, you can use "flushSync".
	----------------------------------
	ReactëŠ” ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì¼ê´„ì²˜ë¦¬í•©ë‹ˆë‹¤.

	ëª¨ë“  ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ê°€ ì‹¤í–‰ë˜ê³  ì„¤ì •ëœ ê¸°ëŠ¥ì„ í˜¸ì¶œí•œ í›„ì—, í™”ë©´ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
	ì´ë ‡ê²Œ í•˜ë©´, ë‹¨ì¼ ì´ë²¤íŠ¸ ì¤‘ì— ì—¬ëŸ¬ ë²ˆ ì¬ë Œë”ë§ë˜ëŠ” ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	ì˜ˆë¥¼ ë“¤ì–´, DOMì— ì•¡ì„¸ìŠ¤í•˜ê¸° ìœ„í•´, Reactê°€ í™”ë©´ì„ ë” ì¼ì° ì—…ë°ì´íŠ¸í•˜ë„ë¡ ê°•ì œí•´ì•¼ í•˜ëŠ” ë“œë¬¸ ê²½ìš°ì—ëŠ”,
	"flashSync"ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


â–  Usage #1 - Adding a "reducer" to a component

  â—‹ Call "useReducer" at the top level of your component to manage "state" with a "reducer":
	----------------------------------
  	"reducer"ë¥¼ ì‚¬ìš©í•˜ì—¬ "ìƒíƒœ"ë¥¼ ê´€ë¦¬í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useReducer"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”:


		import { useReducer } from 'react';

		function reducer(state, action) {
			// ...
		}

		function MyComponent() {
			const [state, dispatch] = useReducer(reducer, { age: 42 });
			// ...

  â—‹ "useReducer" returns an array with exactly two items:
		1. The current state of this state variable, initially set to the initial state you provided.
		2. The "dispatch" function that lets you change it in response to interaction.
	----------------------------------
  	"useReducer"ëŠ” ì •í™•íˆ ë‘ ê°œì˜ í•­ëª©ì´ í¬í•¨ëœ ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤:
		1. ì´ ìƒíƒœë³€ìˆ˜(state variable)ì˜ í˜„ì¬ ìƒíƒœëŠ”, ì²˜ìŒì— ì‚¬ìš©ìê°€ ì œê³µí•œ ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
		2. ìƒí˜¸ì‘ìš©ì— ëŒ€í•œ ì‘ë‹µìœ¼ë¡œ, ì´ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆëŠ” "dispatch(action)" í•¨ìˆ˜.

  â—‹ To update whatâ€™s on the screen, 
  	call "dispatch" with an object representing what the user did, called an "action" :
	----------------------------------
  	í™”ë©´ì— í‘œì‹œëœ ë‚´ìš©ì„ ì—…ë°ì´íŠ¸í•˜ë ¤ë©´, 
    ì‚¬ìš©ìê°€ ìˆ˜í–‰í•œ ì‘ì—…ì„ ë‚˜íƒ€ë‚´ëŠ” "action"ì´ë¼ëŠ” ê°œì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ "dispatch(action)"ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

		function handleClick() {
			dispatch({ type: 'incremented_age' });
		}

  â—‹ React will pass the current state and the action to your "reducer" function.
    Your "reducer" will calculate and return the next state.
    React will store that next state, render your component with it, and update the UI.
	----------------------------------
  	ReactëŠ” í˜„ì¬ìƒíƒœì™€ ì•¡ì…˜(action)ì„ "reducer" í•¨ìˆ˜ì— ì „ë‹¬í•©ë‹ˆë‹¤.
    "reducer"ëŠ” ë‹¤ìŒìƒíƒœë¥¼ ê³„ì‚°í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.
	ReactëŠ” ë‹¤ìŒìƒíƒœë¥¼ ì €ì¥í•˜ê³ , ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”ë§í•˜ê³ , UIë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

  â—‹ "useReducer" is very similar to "useState", 
    but it lets you move the state update logic from event handlers into a single function outside of your component.
	----------------------------------
  	"useReducer"ëŠ” "useState"ì™€ ë§¤ìš° ìœ ì‚¬í•˜ì§€ë§Œ, 
    ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œì§ì„, ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì—ì„œ ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ì˜ ë‹¨ì¼í•¨ìˆ˜ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  â—‹ Example: default app, "src/App.tsx"

		import { useReducer } from 'react';

		function reducer(state, action) {									<--- ***
			if (action.type === 'incremented_age') {
				return {
					age: state.age + 1
				};
			}
			throw Error('Unknown action.');
		}

		export default function Counter() {
			const [state, dispatch] = useReducer(reducer, { age: 42 });		<--- ***

			return (											*action*
				<>									  --------------------------
					<button onClick={() => { dispatch({ type: 'incremented_age' }) }}>
						Increment age
					</button>

					<p>Hello! You are {state.age}.</p>
				</>
			);
		}


â–  Usage #2 - Writing the reducer function

  â—‹ A "reducer" function is declared like this:
						  â‘       â‘¡
						 -----  ------
		function reducer(state, action) {
			// ...
		}

  â—‹ Then you need to fill in the code that will calculate and return the next state.
    By convention, it is common to write it as a "switch" statement. 
	For each case in the switch, calculate and return some next state.
	----------------------------------
  	ê·¸ëŸ° ë‹¤ìŒ, ë‹¤ìŒ ìƒíƒœë¥¼ ê³„ì‚°í•˜ê³  ë°˜í™˜í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.
    ê´€ë¡€ì ìœ¼ë¡œëŠ”, switch ë¬¸ìœ¼ë¡œ ì‘ì„±í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.
	switchì˜ ê° ê²½ìš°ì— ëŒ€í•´, ë‹¤ìŒ ìƒíƒœë¥¼ ê³„ì‚°í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.

						  â‘       â‘¡
						 -----  ------
		function reducer(state, action) {			<--- ***
			switch (action.type) {					<--- ***
				case 'incremented_age': {
					return {
						name: state.name,
						age : state.age + 1
					};
				}
				case 'changed_name': {
					return {
						name: action.nextName,
						age : state.age
					};
				}
			}

			throw Error('Unknown action: ' + action.type);
		}

  â—‹ Actions can have any shape.
    By convention, itâ€™s common to pass objects with a "type" property identifying the action.
	It should include the minimal necessary information that the "reducer" needs to compute the next state.
	----------------------------------
  	ì•¡ì…˜ì˜ í˜•íƒœëŠ” ë‹¤ì–‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    ê´€ë¡€ì ìœ¼ë¡œ, ì•¡ì…˜ì„ ì‹ë³„í•˜ëŠ” ìœ í˜•(type) ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬, ê°ì²´ë¥¼ ì „ë‹¬í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.
    "reducer"ê°€ ë‹¤ìŒ ìƒíƒœë¥¼ ê³„ì‚°í•˜ëŠ” ë° í•„ìš”í•œ ìµœì†Œí•œì˜ í•„ìˆ˜ ì •ë³´ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.

		function Form() {
			const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });
		
			function handleButtonClick() {
								  *action*
						 --------------------------
				dispatch({ type: 'incremented_age' });		
			}

			function handleInputChange(e) {
								  			*action*
						 --------------------------------------------------
				dispatch({ type: 'changed_name', nextName: e.target.value });
			}
			// ...

  â—‹ The "action type" names are local to your component.
    Each action describes a single interaction, even if that leads to multiple changes in data.
	The shape of the "state" is arbitrary, but usually itâ€™ll be an "object" or an "array".
	----------------------------------
 	ì•¡ì…˜(action) ìœ í˜•(type) ì´ë¦„ì€ ì»´í¬ë„ŒíŠ¸ì— ëŒ€í•´ ë¡œì»¬ì…ë‹ˆë‹¤.
	ê° ì‘ì—…ì€, ë°ì´í„°ì— ì—¬ëŸ¬ ë³€ê²½ì‚¬í•­ì´ ë°œìƒí•˜ë”ë¼ë„, ë‹¨ì¼ìƒí˜¸ì‘ìš©ì„ ì„¤ëª…í•©ë‹ˆë‹¤.
	"ìƒíƒœ"ì˜ í˜•íƒœëŠ” ì„ì˜ì ì´ì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ ê°ì²´ ë˜ëŠ” ë°°ì—´ì´ ë©ë‹ˆë‹¤.


â–  Pitfall (í•¨ì •)

  â—‹ State is read-only.
  	Donâ€™t modify any objects or arrays in state:
	----------------------------------
	ìƒíƒœëŠ” ì½ê¸°ì „ìš©ì…ë‹ˆë‹¤.
	ìƒíƒœì˜ ê°ì²´ë‚˜ ë°°ì—´ì„ ìˆ˜ì •í•˜ì§€ ë§ˆì„¸ìš”:
						  ***
				 ---------------------
		function reducer(state, action) {
			switch (action.type) {											<--- ***
				case 'incremented_age': {
					// ğŸš© Don't mutate an object in state like this:	   <--- ***
					state.age = state.age + 1;
					return state;
				}

  â—‹ Instead, always return new objects from your "reducer" :
	----------------------------------
 	ëŒ€ì‹ , í•­ìƒ "reducer" ì—ì„œ ìƒˆ ê°ì²´ë¥¼ ë°˜í™˜í•˜ì„¸ìš” :
						  ***
				 ---------------------
		function reducer(state, action) {
			switch (action.type) {											<--- ***
				case 'incremented_age': {									
					// âœ… Instead, return a new object					  <--- ***
					return {
						...state,
						age: state.age + 1
					};
				}


â–  Example:	default app, "src/App.tsx"

		import { useReducer } from 'react';


						***
				 ---------------------
		function reducer(state, action) {
			switch (action.type) {				<--- ***
				case 'incremented_age': {
					return {
						name: state.name,
						age	: state.age + 1
					};
				}
				case 'changed_name': {
					return {
						name: action.nextName,
						age	: state.age
					};
				}
			}

			throw Error('Unknown action: ' + action.type);
		}

		const initialState = { name: 'Taylor', age: 42 };

		export default
		function Form() {
			const [state, dispatch] = useReducer(reducer, initialState);

			function handleButtonClick() {
				dispatch({ type: 'incremented_age' });
			}

			function handleInputChange(e) {
				dispatch({ type: 'changed_name', nextName: e.target.value }); 
			}

			return (
				<>
					<input value={state.name} onChange={handleInputChange} />
					<button onClick={handleButtonClick}>Increment age</button>
					<p>Hello, {state.name}. You are {state.age}.</p>
				</>
			);
		}


---------------------------------
12. useRef
---------------------------------

â–  The "useRef" is a React Hook that lets you reference a value thatâ€™s not needed for rendering.
	(ë Œë”ë§ì— í•„ìš”í•˜ì§€ ì•Šì€ ê°’ì„ ì°¸ì¡°í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React Hook)

	const ref = useRef(initialValue)


	import { useRef } from 'react';

	function MyComponent() {
		const intervalRef = useRef(0);
		const inputRef = useRef(null);

		// ...

â–  Reference

	useRef(initialValue)

	Call "useRef" at the top level of your component to declare a "ref".
	"ref"ë¥¼ ì„ ì–¸í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useRef"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”:


  â—‹ Parameters

	â— initialValue
	  - The value you want the "ref" objectâ€™s "current" property to be initially.
	  - It can be a value of any type. 
	  - This argument is ignored after the initial render.
	  ----------------------------------
	  - "ref" ê°ì²´ì˜ "current" ì†ì„±ì„ ì´ˆê¸°ì— ì§€ì •í•˜ë ¤ëŠ” ê°’ì…ë‹ˆë‹¤.
	  - ëª¨ë“  ìœ í˜•ì˜ ê°’ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  - ì´ ì¸ìëŠ” ì´ˆê¸° ë Œë”ë§ í›„ì—ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤.


  â—‹ Returns 

	â— "useRef" returns an object with a "single property" :
	  - current: Initially, itâ€™s set to the "initialValue" you have passed.
	  - You can later set it to something else.
	  - If you pass the "ref" object to React as a "ref" attribute to a "JSX" node, 
	    React will set its "current" property.

	  ----------------------------------
	  "useRef"ëŠ” "ë‹¨ì¼ì†ì„±"ì„ ê°€ì§„ ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤ :
	  - í˜„ì¬: ì²˜ìŒì—ëŠ” ì „ë‹¬í•œ "initialValue"ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
  	  - ë‚˜ì¤‘ì— ë‹¤ë¥¸ ê²ƒìœ¼ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  - "ref" ê°ì²´ë¥¼ "JSX" ë…¸ë“œì— ëŒ€í•œ "ref" ì†ì„±ìœ¼ë¡œ Reactì— ì „ë‹¬í•˜ë©´,
	    ReactëŠ” "current" ì†ì„±ì„ ì„¤ì •í•©ë‹ˆë‹¤.

	â— On the "next" renders, "useRef" will return the "same" object.
	  "ë‹¤ìŒ" ë Œë”ë§ì—ì„œ, "useRef"ëŠ” "ë™ì¼í•œ" ê°œì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.


  â—‹ Caveats 
  
	â— You can mutate the "ref.current" property. 
	  Unlike "state", it is mutable.
	  However, if it holds an object that is used for rendering (for example, a piece of your state), 
	  then you shouldnâ€™t mutate that object.
	  ----------------------------------
	  "ref.current" ì†ì„±ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  "ìƒíƒœ"ì™€ ë‹¬ë¦¬, ë³€ê²½ê°€ëŠ¥ í•©ë‹ˆë‹¤.
	  ê·¸ëŸ¬ë‚˜ ë Œë”ë§ì— ì‚¬ìš©ë˜ëŠ” ê°œì²´(ì˜ˆ: ìƒíƒœì˜ ì¼ë¶€)ë¥¼ ë³´ìœ í•˜ëŠ” ê²½ìš°, í•´ë‹¹ ê°œì²´ë¥¼ ë³€ê²½í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.

	â— When you change the "ref.current" property, React does *NOT* re-render your component.
	  React is *NOT* aware of when you change it because a "ref" is a plain JavaScript object.
	  ----------------------------------
	  "ref.current" ì†ì„±ì„ ë³€ê²½í•˜ë©´, ReactëŠ” ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	  "ref"ëŠ” ì¼ë°˜ JavaScript ê°ì²´ì´ê¸° ë•Œë¬¸ì—, ReactëŠ” ì–¸ì œ ë³€ê²½ë˜ëŠ”ì§€ ì¸ì‹í•˜ì§€ ëª»í•©ë‹ˆë‹¤.

	â— Do *NOT* write or read "ref.current" during rendering, except for initialization.
	  This makes your componentâ€™s behavior unpredictable.
	  ----------------------------------
	  ì´ˆê¸°í™”ë¥¼ ì œì™¸í•˜ê³ , ë Œë”ë§ ì¤‘ì— "ref.current"ë¥¼ ì“°ê±°ë‚˜ ì½ì§€ *ì•ŠìŠµë‹ˆë‹¤*.
	  ì´ë¡œì¸í•´, ì»´í¬ë„ŒíŠ¸ì˜ ë™ì‘ì„ ì˜ˆì¸¡í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.

	â— In Strict Mode, React will call your component function *Twice* in order to help you find accidental impurities.
	  This is development-only behavior and does *NOT* affect production.
	  Each "ref" object will be created *Twice*, but one of the versions will be discarded.
	  If your component function is pure (as it should be), this should *NOT* affect the behavior.
	  ----------------------------------
	  Strict ëª¨ë“œì—ì„œ ReactëŠ”, ìš°ë°œì ì¸ ë¶ˆìˆœë¬¼ì„ ì°¾ëŠ”ë° ë„ì›€ì„ ì£¼ê¸°ìœ„í•´, ì»´í¬ë„ŒíŠ¸ í•¨ìˆ˜ë¥¼ *ë‘ë²ˆ* í˜¸ì¶œí•©ë‹ˆë‹¤.
	  ì´ëŠ” ê°œë°œì „ìš© ë™ì‘ì´ë©°, í”„ë¡œë•ì…˜ì—ëŠ” *ì•„ë‹™ë‹ˆë‹¤*.
	  ê° "ref" ê°œì²´ëŠ” *ë‘ë²ˆ* ìƒì„±ë˜ì§€ë§Œ, ë²„ì „ ì¤‘ í•˜ë‚˜ëŠ” ì‚­ì œë©ë‹ˆë‹¤.
	  ì»´í¬ë„ŒíŠ¸ í•¨ìˆ˜ê°€ ìˆœìˆ˜í•˜ë‹¤ë©´(ë˜ì–´ì•¼ í•˜ëŠ”ëŒ€ë¡œ), ë™ì‘ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.

â–  Usage #1	- Referencing a value with a "ref"

  â—‹ Call "useRef" at the top level of your component to declare one or more "refs" :
	----------------------------------
    í•˜ë‚˜ ì´ìƒì˜ "refs"ë¥¼ ì„ ì–¸í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useRef"ë¥¼ í˜¸ì¶œí•˜ì„¸ìš” :

		import { useRef } from 'react';				<--- ***

		function Stopwatch() {
			const intervalRef = useRef(0);			<--- ***

			// ...

  â—‹ "useRef" returns a "ref" object with a single "current" property initially set to the initial value you provided.
	----------------------------------
	"useRef"ëŠ” ì²˜ìŒì— ì‚¬ìš©ìê°€ ì œê³µí•œ ì´ˆê¸°ê°’ìœ¼ë¡œ ì„¤ì •ëœ, ë‹¨ì¼ "current" ì†ì„±ì´ ìˆëŠ” "ref" ê°œì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

  â—‹ On the next renders, "useRef" will return the "same" object.
  	You can change its "current" property to store information and read it later.
	This might remind you of "state", but there is an important difference.
	----------------------------------
	ë‹¤ìŒ ë Œë”ë§ì—ì„œ, "useRef"ëŠ” "ë™ì¼í•œ" ê°œì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
	ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ë‚˜ì¤‘ì— ì½ì„ ìˆ˜ ìˆë„ë¡, "í˜„ì¬" ì†ì„±ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	ì´ëŠ” "ìƒíƒœ"ë¥¼ ìƒê°ë‚˜ê²Œ í•  ìˆ˜ ìˆì§€ë§Œ, ì¤‘ìš”í•œ ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤.

  â—‹ Changing a "ref" does *NOT* trigger a "re-render".
	This means "refs" are perfect for storing information that doesnâ€™t affect the visual output of your component.
  	For example, if you need to store an interval ID and retrieve it later, you can put it in a "ref". 
	----------------------------------
	"ref"ë¥¼ ë³€ê²½í•´ë„ "ì¬ë Œë”ë§"ì´ íŠ¸ë¦¬ê±°ë˜ì§€ *ì•ŠìŠµë‹ˆë‹¤*.
	ì´ëŠ” "refs"ê°€, ì»´í¬ë„ŒíŠ¸ì˜ ì‹œê°ì  ì¶œë ¥ì— ì˜í–¥ì„ ì£¼ì§€ì•ŠëŠ” ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ”ë°, ì í•©í•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
	ì˜ˆë¥¼ ë“¤ì–´, interval IDë¥¼ ì €ì¥í•˜ê³  ë‚˜ì¤‘ì— ê²€ìƒ‰í•´ì•¼ í•˜ëŠ” ê²½ìš°, ì´ë¥¼ "ref"ì— ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  	To update the value inside the "ref", you need to "manually" change its "current" property:
	----------------------------------
	"ref" ë‚´ë¶€ì˜ ê°’ì„ ì—…ë°ì´íŠ¸í•˜ë ¤ë©´, í•´ë‹¹ "current" ì†ì„±ì„ "ìˆ˜ë™ìœ¼ë¡œ" ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤ :

		function handleStartClick() {
			const intervalId = setInterval(() => {	<--- ***
				// ...
			}, 1000);

			intervalRef.current = intervalId;		<--- ***
		}

  â—‹ Later, you can read that interval ID from the "ref" so that you can call "clear" that interval:
	----------------------------------
	ë‚˜ì¤‘ì—, í•´ë‹¹ interval ì„ "ì§€ìš°ê¸°" í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡, "ref"ì—ì„œ í•´ë‹¹ interval IDë¥¼ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

		function handleStopClick() {
			const intervalId = intervalRef.current;	<--- ***
			clearInterval(intervalId);				<--- ***
		}

  â—‹ By using a "ref", you ensure that:
	----------------------------------
	"ref"ë¥¼ ì‚¬ìš©í•˜ë©´, ë‹¤ìŒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

	â— You can store information between "re-renders"
	  (unlike regular variables, which reset on "every render").
	  ----------------------------------
	  "ì¬ë Œë”ë§" í•  ë•Œë§ˆë‹¤, ì •ë³´ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	  ("ëª¨ë“  ë Œë”ë§"ì—ì„œ ì¬ì„¤ì •ë˜ëŠ” ì¼ë°˜ë³€ìˆ˜ì™€ëŠ” ë‹¤ë¦„)

	â— Changing it does *NOT* trigger a "re-render"
	  (unlike "state variables", which trigger a "re-render").
	  ----------------------------------
	  ì´ë¥¼ ë³€ê²½í•´ë„, "ì¬ë Œë”ë§"ì´ íŠ¸ë¦¬ê±° ë˜ì§€ *ì•ŠìŠµë‹ˆë‹¤*.
	  ("ì¬ë Œë”ë§"ì„ íŠ¸ë¦¬ê±°í•˜ëŠ” "ìƒíƒœë³€ìˆ˜"ì™€ëŠ” ë‹¤ë¦„)

	â— The information is local to "each" copy of your component
	  (unlike the variables outside, which are shared).
	  ----------------------------------
	  ì •ë³´ëŠ”, ì»´í¬ë„ŒíŠ¸ì˜ "ê°" ë³µì‚¬ë³¸ì— ëŒ€í•´, ë¡œì»¬ì…ë‹ˆë‹¤
	  (ê³µìœ ë˜ëŠ” ì™¸ë¶€ë³€ìˆ˜ì™€ëŠ” ë‹¬ë¦¬)

  â—‹ Changing a "ref" does *NOT* trigger a "re-render",
    so "refs" are *NOT* appropriate for storing information you want to display on the screen.
  	Use "state" for that instead.
	----------------------------------
	"ref"ë¥¼ ë³€ê²½í•´ë„, "ì¬ë Œë”ë§"ì„ íŠ¸ë¦¬ê±° í•˜ì§€ *ì•„ë‹™ë‹ˆë‹¤*.
	ë”°ë¼ì„œ, "refs"ëŠ” í™”ë©´ì— í‘œì‹œí•˜ë ¤ëŠ” ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë°, ì ì ˆí•˜ì§€ *ì•ŠìŠµë‹ˆë‹¤*.
	ëŒ€ì‹  "ìƒíƒœ"ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.

  â—‹ If you show "{ref.current}" in the JSX, the number wonâ€™t update on click.
    This is because setting "ref.current" does *NOT* trigger a "re-render".
	Information thatâ€™s used for rendering should be "state" instead.
	----------------------------------
	JSXì— "{ref.current}"ë¥¼ í‘œì‹œí•˜ë©´, í´ë¦­ ì‹œ ìˆ«ìê°€ ì—…ë°ì´íŠ¸ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
	ì´ëŠ” "ref.current"ë¥¼ ì„¤ì •í•´ë„ "ì¬ë Œë”ë§"ì´ íŠ¸ë¦¬ê±°ë˜ì§€ *ì•Šê¸°* ë•Œë¬¸ì…ë‹ˆë‹¤.
	ëŒ€ì‹  ë Œë”ë§ì— ì‚¬ìš©ë˜ëŠ” ì •ë³´ëŠ” "ìƒíƒœ" ì—¬ì•¼ í•©ë‹ˆë‹¤.


  â—‹ Pitfall (í•¨ì •)
	
	Do not write or read "ref.current" during rendering.
	----------------------------------
	ë Œë”ë§ ì¤‘ì—ëŠ” "ref.current"ë¥¼ ì“°ê±°ë‚˜ ì½ì§€ ë§ˆì‹­ì‹œì˜¤.

	React expects that the body of your component behaves like a pure function:
	----------------------------------
	ReactëŠ” ì»´í¬ë„ŒíŠ¸ì˜ ë³¸ë¬¸ì´, ìˆœìˆ˜í•œ í•¨ìˆ˜ì²˜ëŸ¼ ë™ì‘í•  ê²ƒìœ¼ë¡œ ê¸°ëŒ€í•©ë‹ˆë‹¤.

	â— If the inputs ("props", "state", and "context") are the "same", it should return exactly the "same" JSX.
	  ----------------------------------
	  ì…ë ¥("props", "state" ë° "context")ì´ "ë™ì¼"í•˜ë©´, ì •í™•íˆ "ë™ì¼í•œ" JSXë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.

	â— Calling it in a different order or with different arguments should *NOT* affect the results of other calls.
	  ----------------------------------
	  ë‹¤ë¥¸ ìˆœì„œë‚˜ ë‹¤ë¥¸ ì¸ìë¡œ í˜¸ì¶œí•˜ë©´, ë‹¤ë¥¸ í˜¸ì¶œì˜ ê²°ê³¼ì— *ì˜í–¥ì„ ì£¼ì§€* ì•ŠìŠµë‹ˆë‹¤.

  	Reading or writing a "ref" during "rendering" breaks these expectations:
	----------------------------------
	"ë Œë”ë§" ì¤‘ì— "ref"ë¥¼ ì½ê±°ë‚˜ ì“°ëŠ” ê²ƒì€, ì´ëŸ¬í•œ ê¸°ëŒ€ë¥¼ ê¹¨ëœ¨ë¦½ë‹ˆë‹¤.

		function MyComponent() {
			// ...

			// ğŸš© Don't write a "ref" during "rendering"
			myRef.current = 123;

			// ...

			// ğŸš© Don't read a "ref" during "rendering"
			return <h1>{myOtherRef.current}</h1>;
		}

	You can read or write "refs" from "event handlers" or "effects" instead:
	----------------------------------
	ëŒ€ì‹ , "ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬"ë‚˜ "íš¨ê³¼"ì—ì„œ, "refs"ë¥¼ ì½ê±°ë‚˜ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

		function MyComponent() {
			// ...

			useEffect(() => {
				// âœ… You can read or write "refs" in "effects"
				myRef.current = 123;
			});

			// ...

			function handleClick() {
				// âœ… You can read or write "refs" in "event handlers"
				doSomething(myOtherRef.current);
			}

			// ...
		}

	If you have to read or write something during "rendering", use "state" instead.
	When you break these rules, your component might still work, 
	but most of the newer features weâ€™re adding to React will rely on these expectations.
	----------------------------------
	"ë Œë”ë§" ì¤‘ì— ë¬´ì–¸ê°€ë¥¼ ì½ê±°ë‚˜ ì¨ì•¼ í•œë‹¤ë©´, ëŒ€ì‹  "ìƒíƒœ"ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
	ì´ëŸ¬í•œ ê·œì¹™ì„ ì–´ê¸°ë©´, ì»´í¬ë„ŒíŠ¸ê°€ ê³„ì† ì‘ë™í•  ìˆ˜ ìˆì§€ë§Œ,
	Reactì— ì¶”ê°€í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ê¸°ëŠ¥ì€ ì´ëŸ¬í•œ ê¸°ëŒ€ì— ì˜ì¡´í•©ë‹ˆë‹¤.

â–  Usage #2	- Manipulating the DOM with a "ref"

  â—‹ Itâ€™s particularly common to use a "ref" to manipulate the "DOM".
  	React has built-in support for this.

	First, declare a "ref" object with an initial value of "null" :

		import { useRef } from 'react';

		function MyComponent() {
			const inputRef = useRef(null);			<--- ***
			// ...

  â—‹ Then pass your "ref" object as the "ref" attribute 
  	to the "JSX" of the "DOM" node you want to manipulate:

		// ...

  		return <input ref={inputRef} />;			<--- ***

  â—‹ After React creates the "DOM" node and puts it on the screen,
  	React will set the "current" property of your "ref" object to that "DOM" node.
	----------------------------------
	Reactê°€ "DOM" ë…¸ë“œë¥¼ ìƒì„±í•˜ì—¬ í™”ë©´ì— í‘œì‹œí•œ í›„, 
	ReactëŠ” "ref" ê°ì²´ì˜ "current" ì†ì„±ì„ í•´ë‹¹ "DOM" ë…¸ë“œë¡œ ì„¤ì •í•©ë‹ˆë‹¤.

	Now you can access the <input>â€™s "DOM" node and call methods like "focus()" :
	----------------------------------
	ì´ì œ <input>ì˜ "DOM" ë…¸ë“œì— ì•¡ì„¸ìŠ¤í•˜ê³ , "focus()"ì™€ ê°™ì€ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ :

		function handleClick() {
			inputRef.current.focus();				<--- ***
		}

  â—‹ React will set the "current" property back to "null" when the node is removed from the screen.
	----------------------------------
    ReactëŠ”, ë…¸ë“œê°€ í™”ë©´ì—ì„œ ì œê±°ë˜ë©´, "current" ì†ì„±ì„ ë‹¤ì‹œ "null"ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.


---------------------------------
13. useState
---------------------------------

â–  The "useState" is a React Hook that lets you add a "state variable" to your component.
  (ë‹¹ì‹ ì˜ Component ì— ìƒíƒœ ë³€ìˆ˜(state variable)ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React Hook)

		const [state, setState] = useState(initialState)


â–  Reference #1	- useState(initialState)

  â—‹ Call "useState" at the top level of your component to declare a "state variable":
	(ìƒíƒœ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë ¤ë©´, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ useStateë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.)

		import { useState } from 'react';

		function MyComponent() {
			const [age, setAge] = useState(28);
			const [name, setName] = useState('Taylor');
			const [todos, setTodos] = useState(() => createTodos());

			// ...

  â—‹ The convention is to name "state variables" like "[something, setSomething]" using "array destructuring".
    (ê´€ë¡€ëŠ” "ë°°ì—´ ë¶„í•´"ë¥¼ ì‚¬ìš©í•˜ì—¬, "[something, setSomething]"ê³¼ ê°™ì€, "ìƒíƒœ ë³€ìˆ˜"ì˜ ì´ë¦„ì„ ì§€ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.)


  â—‹ Parameters

	â‘  initialState: 
	
	  - The value you want the state to be initially.
	  - It can be a value of any type, but there is a special behavior for functions.
	  - This argument is ignored after the initial render.
	  - If you pass a "function" as "initialState", it will be treated as an "initializer" function.
	    It should be pure, should take no arguments, and should return a value of any type.
	    React will call your "initializer" function when initializing the component, and store its return value as the initial state.

		------------------------------------

	  - ì›í•˜ëŠ” ì²˜ìŒ ìƒíƒœì˜ ê°’ì…ë‹ˆë‹¤.
	  - ëª¨ë“  ìœ í˜•ì˜ ê°’ì´ ë  ìˆ˜ ìˆì§€ë§Œ, í•¨ìˆ˜ì—ëŠ” íŠ¹ë³„í•œ ë™ì‘ì´ ìˆìŠµë‹ˆë‹¤.
	  - ì´ ì¸ìëŠ”, ì´ˆê¸° ë Œë”ë§ í›„ì—ëŠ”, ë¬´ì‹œë©ë‹ˆë‹¤.
	  - í•¨ìˆ˜ë¥¼ initialStateë¡œ ì „ë‹¬í•˜ë©´, ì´ˆê¸°í™” í•¨ìˆ˜ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
	    ìˆœìˆ˜í•´ì•¼ í•˜ê³ , ì¸ìë¥¼ ì·¨í•˜ì§€ ì•Šì•„ì•¼ í•˜ë©°, ëª¨ë“  ìœ í˜•ì˜ ê°’ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
		ReactëŠ”, ì»´í¬ë„ŒíŠ¸ë¥¼ ì´ˆê¸°í™”í•  ë•Œ, ì´ˆê¸°í™” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê³  ê·¸ ë°˜í™˜ ê°’ì„ ì´ˆê¸°ìƒíƒœ(initial state)ë¡œ ì €ì¥í•©ë‹ˆë‹¤.


  â—‹ Returns 

	"useState" returns an "array" with exactly two values:

		â‘  The current state. 
			During the first render, it will match the "initialState" you have passed.
		â‘¡ The "set" function that lets you update the state to a different value and trigger a "re-render".

		------------------------------------

	"useState"ëŠ” ì •í™•íˆ ë‘ ê°œì˜ ê°’ì´ ìˆëŠ” "ë°°ì—´"ì„ ë°˜í™˜í•©ë‹ˆë‹¤:

		â‘  í˜„ì¬ ìƒíƒœì…ë‹ˆë‹¤. ì²« ë²ˆì§¸ ë Œë”ë§ ì¤‘ì—ëŠ”, ì „ë‹¬í•œ "initialState"ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤.
		â‘¡ ìƒíƒœë¥¼ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , "ì¬ë Œë”ë§"ì„ "íŠ¸ë¦¬ê±°" í•  ìˆ˜ ìˆëŠ” "set" í•¨ìˆ˜.


  â—‹ Caveats - (íŠ¹ì • ì ˆì°¨ë¥¼ ë”°ë¥´ë¼ëŠ”) í†µê³ [ê²½ê³ ]

	â‘  "useState" is a Hook, so you can only call it at the top level of your component or your own Hooks.

	   	- You canâ€™t call it inside "loops" or "conditions".
	   	- If you need that, extract a new component and move the "state" into it.

	â‘¡ In Strict Mode, React will call your "initializer" function *Twice* in order to help you find accidental impurities.

	   	- This is development-only behavior and does not affect production.
	   	- If your "initializer" function is pure (as it should be), this should not affect the behavior.
	   	- The result from one of the calls will be ignored.

		------------------------------------

	â‘  useStateëŠ” Hookì´ë¯€ë¡œ, ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì´ë‚˜ ìì²´ Hookì—ì„œë§Œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	
	   	- ë£¨í”„ë‚˜ ì¡°ê±´ ë‚´ì—ì„œëŠ” í˜¸ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
	   	- í•„ìš”í•œ ê²½ìš° ìƒˆ ì»´í¬ë„ŒíŠ¸ë¥¼ ì¶”ì¶œí•˜ê³ , ìƒíƒœë¥¼ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ë¡œ ì˜®ê¹ë‹ˆë‹¤.

	â‘¡ Strict ëª¨ë“œì—ì„œ, ReactëŠ” ìš°ë°œì ì¸ ë¶ˆìˆœë¬¼ì„ ì°¾ëŠ”ë° ë„ì›€ì„ ì£¼ê¸° ìœ„í•´, ì´ˆê¸°í™” í•¨ìˆ˜ë¥¼ *ë‘ë²ˆ* í˜¸ì¶œí•©ë‹ˆë‹¤.
	
		- ì´ëŠ” ê°œë°œ ì „ìš© ë™ì‘ì´ë©°, í”„ë¡œë•ì…˜ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
		- ì´ˆê¸°í™” í•¨ìˆ˜ê°€ ìˆœìˆ˜(ìˆœìˆ˜í•´ì•¼ í•¨)ì¸ ê²½ìš°, ì´ëŠ” ë™ì‘ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
		- í˜¸ì¶œ ì¤‘ í•˜ë‚˜ì˜ ê²°ê³¼ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤.
	

â–  Reference #2	- set functions, like setSomething(nextState)

  â—‹ The set function returned by "useState" lets you update the "state" to a different value and trigger a "re-render".
  	You can pass the next state directly, or a function that calculates it from the previous state:

	------------------------------------

	"useState"ì—ì„œ ë°˜í™˜ëœ set í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´, ìƒíƒœ("state")ë¥¼ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³  ì¬ë Œë”ë§("re-render")ì„ íŠ¸ë¦¬ê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	ë‹¤ìŒ ìƒíƒœ(state)ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ê±°ë‚˜ ì´ì „ ìƒíƒœ(previous state)ì—ì„œ ì´ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

		const [name, setName] = useState('Edward');				<--- ***

		function handleClick() {
			setName('Taylor');									<--- ***
			setAge(a => a + 1);

			// ...


  â—‹ Parameters

	â‘  nextState: The value that you want the "state" to be. 

		- It can be a "value" of any type, but there is a special behavior for functions.
		- If you pass a "function" as nextState, it will be treated as an "updater" function.
		- It must be pure, should take the "pending state" as its only argument, and should return the "next state".
		- React will put your "updater" function in a "queue" and "re-render" your component.
		- During the next render, React will calculate the next state by applying all of the "queued updaters" to the "previous state".

		------------------------------------

		"ìƒíƒœ"ì— ì›í•˜ëŠ” ê°’ì…ë‹ˆë‹¤.

		- ëª¨ë“  ìœ í˜•ì˜ "ê°’"ì´ ë  ìˆ˜ ìˆì§€ë§Œ, í•¨ìˆ˜ì—ëŠ” íŠ¹ë³„í•œ ë™ì‘ì´ ìˆìŠµë‹ˆë‹¤.
		- "í•¨ìˆ˜"ë¥¼ nextStateë¡œ ì „ë‹¬í•˜ë©´, "ì—…ë°ì´í„°" í•¨ìˆ˜ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
		- ìˆœìˆ˜í•´ì•¼ í•˜ë©°, "ë³´ë¥˜ ìƒíƒœ"ë¥¼ ìœ ì¼í•œ ì¸ìë¡œ ê°€ì ¸ì™€ì•¼ í•˜ë©°, "ë‹¤ìŒ ìƒíƒœ"ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.
		- ReactëŠ” "ì—…ë°ì´í„°" í•¨ìˆ˜ë¥¼ "ëŒ€ê¸°ì—´"ì— ë„£ê³ , ì»´í¬ë„ŒíŠ¸ë¥¼ "ë‹¤ì‹œ ë Œë”ë§"í•©ë‹ˆë‹¤.
		- ë‹¤ìŒ ë Œë”ë§ ë™ì•ˆ, ReactëŠ” ëª¨ë“  "ëŒ€ê¸° ì¤‘ì¸ ì—…ë°ì´í„°"ì„ "ì´ì „ ìƒíƒœ"ì— ì ìš©í•˜ì—¬, ë‹¤ìŒ ìƒíƒœë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

		------------------------------------


  â—‹ Returns

	- set functions do not have a return value.
	  (set í•¨ìˆ˜ì—ëŠ” ë°˜í™˜ ê°’ì´ ì—†ìŠµë‹ˆë‹¤.)


  â—‹ Caveats - (íŠ¹ì • ì ˆì°¨ë¥¼ ë”°ë¥´ë¼ëŠ”) í†µê³ [ê²½ê³ ]

	- The "set" function *ONLY* updates the "state variable" for the next render.
	  If you read the "state variable" after calling the "set" function, you will still get the old value that was on the screen before your call.

	  -------------------------

	  "set" í•¨ìˆ˜ëŠ”, *ì˜¤ì§* ë‹¤ìŒ ë Œë”ë§ì„ ìœ„í•´, "ìƒíƒœ ë³€ìˆ˜"ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. 
	  "set" í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ í›„ "ìƒíƒœ ë³€ìˆ˜"ë¥¼ ì½ìœ¼ë©´, í˜¸ì¶œí•˜ê¸° ì „ì— í™”ë©´ì— ìˆì—ˆë˜ ì´ì „ ê°’ì„ ê³„ì† ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	- If the new value you provide is identical to the current state, as determined by an "Object.is" comparison,
	  React will skip re-rendering the component and its children. 
	  This is an optimization. 
	  Although in some cases React may still need to call your component before skipping the children, it shouldnâ€™t affect your code.

	  -------------------------

	  ìƒˆë¡­ê²Œ ì œê³µí•œ ê°’ì´, "Object.is" ë¹„êµì— ì˜í•´ ê²°ì •ëœ, í˜„ì¬ ìƒíƒœì™€ ë™ì¼í•˜ë©´,
	  ReactëŠ” ì»´í¬ë„ŒíŠ¸ì™€ ê·¸ í•˜ìœ„ìš”ì†Œ(children)ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ëŠ” ê²ƒì„ ê±´ë„ˆëœë‹ˆë‹¤.
	  
	  ì´ê²ƒì€ ìµœì í™”ì…ë‹ˆë‹¤.
	  
	  ê²½ìš°ì— ë”°ë¼ ReactëŠ”, í•˜ìœ„ìš”ì†Œ(ì»´í¬ë„ŒíŠ¸)ë¥¼ ê±´ë„ˆë›°ê¸° ì „ì—, ì»´í¬ë„ŒíŠ¸ë¥¼ í˜¸ì¶œí•´ì•¼ í•  ìˆ˜ë„ ìˆì§€ë§Œ, 
	  ì´ê²ƒì´ ì½”ë“œì— ì˜í–¥ì„ ì£¼ì–´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.

	- React batches state updates.

	  It updates the screen after all the event handlers have run and have called their set functions.
	  This prevents multiple re-renders during a single event.

	  In the rare case that you need to force React to update the screen earlier,
	  for example to access the DOM, you can use "flushSync".

	  -------------------------

	  ReactëŠ” ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì¼ê´„ì²˜ë¦¬ í•©ë‹ˆë‹¤.

	  ëª¨ë“  ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ê°€ ì‹¤í–‰ë˜ê³  "set" í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ í›„ì— í™”ë©´ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
	  ì´ë ‡ê²Œ í•˜ë©´, ë‹¨ì¼ ì´ë²¤íŠ¸ ì¤‘ì—, ì—¬ëŸ¬ ë²ˆ ë‹¤ì‹œ ë Œë”ë§ë˜ëŠ” ê²ƒì„, ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	  ì˜ˆë¥¼ë“¤ì–´, DOMì— ì•¡ì„¸ìŠ¤í•˜ê¸° ìœ„í•´, Reactê°€ í™”ë©´ì„ ë” ì¼ì° ì—…ë°ì´íŠ¸í•˜ë„ë¡ ê°•ì œí•´ì•¼ í•˜ëŠ” ë“œë¬¸ ê²½ìš°ì—ëŠ”,
	  "flushSync"ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	- Calling the set function during rendering is only allowed from within the currently rendering component.
	  React will discard its output and immediately attempt to render it again with the new state.
	  This pattern is rarely needed, but you can use it to store information from the previous renders.

	  -------------------------

	  ë Œë”ë§ ì¤‘ì—, set í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€, í˜„ì¬ ë Œë”ë§ ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œë§Œ í—ˆìš©ë©ë‹ˆë‹¤.
	  ReactëŠ” ì¶œë ¥ì„ ì‚­ì œí•˜ê³ , ì¦‰ì‹œ ìƒˆ ìƒíƒœë¡œ ë‹¤ì‹œ ë Œë”ë§ì„ ì‹œë„í•©ë‹ˆë‹¤.
	  ì´ íŒ¨í„´ì€ ê±°ì˜ í•„ìš”í•˜ì§€ ì•Šì§€ë§Œ, ì´ì „ ë Œë”ë§ì˜ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

	- In Strict Mode, React will call your updater function twice in order to help you find accidental impurities.
	  This is development-only behavior and does not affect production.
	  If your updater function is pure (as it should be), this should not affect the behavior.
	  The result from one of the calls will be ignored. 

	  -------------------------

	  Strict ëª¨ë“œì—ì„œ, ReactëŠ” ìš°ë°œì ì¸ ë¶ˆìˆœë¬¼ì„ ì°¾ëŠ” ë° ë„ì›€ì„ ì£¼ê¸° ìœ„í•´, ì—…ë°ì´í„° í•¨ìˆ˜ë¥¼ ë‘ ë²ˆ í˜¸ì¶œí•©ë‹ˆë‹¤.
	  ì´ëŠ” ê°œë°œì „ìš© ë™ì‘ì´ë©°, í”„ë¡œë•ì…˜ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
	  ì—…ë°ì´í„° í•¨ìˆ˜ê°€ ìˆœìˆ˜í•˜ë‹¤ë©´(ë˜ì–´ì•¼ í•˜ëŠ” ëŒ€ë¡œ), ë™ì‘ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤. \
	  í˜¸ì¶œ ì¤‘ í•˜ë‚˜ì˜ ê²°ê³¼ëŠ” ë¬´ì‹œë©ë‹ˆë‹¤.


â–  Usage #1	- Adding "state" to a component

  â—‹ Call "useState" at the top level of your component to declare "one" or "more" state variables:
	------------------------------------
	ì»´í¬ë„ŒíŠ¸ì˜ ìµœìƒìœ„ ìˆ˜ì¤€ì—ì„œ "useState"ë¥¼ í˜¸ì¶œí•˜ì—¬, "í•˜ë‚˜" ë˜ëŠ” "ë” ë§ì€" ìƒíƒœë³€ìˆ˜ë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.


		import { useState } from 'react';					<--- ***

		function MyComponent() {
			const [age, setAge] = useState(42);				<--- ***
			const [name, setName] = useState('Taylor');		<--- ***

			// ...

  â—‹ The convention is to name "state variables" like "[something, setSomething]" using array destructuring.
	------------------------------------
	ê·œì¹™ì€ "ë°°ì—´ë¶„í•´"ë¥¼ ì‚¬ìš©í•˜ì—¬, "[something, setSomething]"ê³¼ ê°™ì€, "ìƒíƒœ ë³€ìˆ˜"ì˜ ì´ë¦„ì„ ì§€ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.


  â—‹ "useState" returns an array with exactly two items:
	â‘  The current state of this state variable, initially set to the "initial state" you provided.
	â‘¡ The "set" function that lets you change it to any other value in response to interaction.

	------------------------------------

	"useState"ëŠ” ì •í™•íˆ ë‘ ê°œì˜ í•­ëª©ì´ í¬í•¨ëœ ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤:
	â‘  ì´ ìƒíƒœë³€ìˆ˜ì˜ í˜„ì¬ìƒíƒœëŠ”, ì²˜ìŒì— ì‚¬ìš©ìê°€ ì œê³µí•œ "ì´ˆê¸°ìƒíƒœ"ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
	â‘¡ ìƒí˜¸ì‘ìš©ì— ë”°ë¼, ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆëŠ” "set" í•¨ìˆ˜.


  â—‹ To update whatâ€™s on the screen, call the "set" function with some next state:
	------------------------------------
	í™”ë©´ì˜ ë‚´ìš©ì„ ì—…ë°ì´íŠ¸í•˜ë ¤ë©´, ë‹¤ìŒ ìƒíƒœë¡œ "set" í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.

		function handleClick() {							<--- ***
			setName('Robin');								<--- ***
		}

  â—‹ React will store the next state, render your component again with the new values, and update the UI.
	------------------------------------
	ReactëŠ” ë‹¤ìŒ ìƒíƒœë¥¼ ì €ì¥í•˜ê³ , ìƒˆ ê°’ìœ¼ë¡œ ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ê³ , UIë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.


  â—‹ Pitfall (í•¨ì •)

	- Calling the set function does not change the current state in the already executing code:
	  ------------------------------------
	  set í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë„, ì´ë¯¸ ì‹¤í–‰ì¤‘ì¸ ì½”ë“œì˜ í˜„ì¬ìƒíƒœëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:


		function handleClick() {							<--- ***
			setName('Robin');								<--- ***
			console.log(name); // Still "Taylor"!			<--- ***
		}
  
	- It only affects what "useState" will return starting from the next render.
	  ------------------------------------
	  ì´ëŠ”, ë‹¤ìŒ ë Œë”ë§ë¶€í„°, "useState"ê°€ ë°˜í™˜í•  ë‚´ìš©ì—ë§Œ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤.


â–  Usage #2	- Updating "state" based on the "previous" state

  â—‹ Suppose the age is 42.
  	This handler calls setAge(age + 1) three times:
	------------------------------------
	ë‚˜ì´ê°€ 42ì„¸ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤.
	ì´ í•¸ë“¤ëŸ¬ëŠ” setAge(age + 1)ì„ ì„¸ ë²ˆ í˜¸ì¶œí•©ë‹ˆë‹¤:


		function handleClick() {
			setAge(age + 1); 		// setAge(42 + 1)			<--- ***
			setAge(age + 1); 		// setAge(42 + 1)			<--- ***
			setAge(age + 1); 		// setAge(42 + 1)			<--- ***
		}


  â—‹ However, after one click, age will only be 43 rather than 45!.
    This is because calling the set function does *NOT* update the age "state variable" in the already running code.
	------------------------------------
	ê·¸ëŸ¬ë‚˜, í•œ ë²ˆì˜ í´ë¦­ í›„ì—ëŠ”, ë‚˜ì´ê°€ 45ì„¸ê°€ ì•„ë‹Œ 43ì„¸ë¡œ í‘œì‹œë©ë‹ˆë‹¤!.
	ì´ëŠ” set í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë„, "ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸" ì½”ë“œì˜ ì—°ë ¹ "ìƒíƒœë³€ìˆ˜"ê°€ ì—…ë°ì´íŠ¸ë˜ì§€ *ì•Šê¸°* ë•Œë¬¸ì…ë‹ˆë‹¤.
	
	So each setAge(age + 1) call becomes setAge(43).
	------------------------------------
	ë”°ë¼ì„œ, ê° setAge(age + 1) í˜¸ì¶œì€, setAge(43)ì´ ë©ë‹ˆë‹¤.


  â—‹ To solve this problem, you may pass an "updater" function to "setAge" instead of the "next state":
	------------------------------------
	ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´, "ë‹¤ìŒìƒíƒœ" ëŒ€ì‹ , "updater" í•¨ìˆ˜ë¥¼ "setAge"ì— ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


		function handleClick() {
			setAge(a => a + 1); 	// setAge(42 => 43)			<--- ***
			setAge(a => a + 1); 	// setAge(43 => 44)			<--- ***
			setAge(a => a + 1); 	// setAge(44 => 45)			<--- ***
		}


  â—‹ Here, "a => a + 1" is your "updater" function.
  	It takes the "pending state" and calculates the "next state" from it.
	------------------------------------
	ì—¬ê¸°ì„œ, "a => a + 1"ì€ "ì—…ë°ì´í„°" í•¨ìˆ˜ ì…ë‹ˆë‹¤.
	"ë³´ë¥˜ìƒíƒœ"(pending state)ë¥¼ ê°€ì ¸ì™€ì„œ, "ë‹¤ìŒìƒíƒœ"(next state)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.


  â—‹ React puts your "updater" functions in a "queue".
  	Then, during the "next" render, it will call them in the "same" order:
	------------------------------------
	ReactëŠ” "ì—…ë°ì´íŠ¸" ê¸°ëŠ¥ì„ "ëŒ€ê¸°ì—´"ì— ë„£ìŠµë‹ˆë‹¤.
	ê·¸ëŸ° ë‹¤ìŒ, "ë‹¤ìŒ" ë Œë”ë§ ì¤‘ì—, "ë™ì¼í•œ" ìˆœì„œë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.

	"a => a + 1" will receive 42 as the "pending state" and return 43 as the "next state".
	"a => a + 1" will receive 43 as the "pending state" and return 44 as the "next state".
	"a => a + 1" will receive 44 as the "pending state" and return 45 as the "next state".


  â—‹ There are *No* other queued updates, so React will store 45 as the "current state" in the end.
	------------------------------------
	ëŒ€ê¸° ì¤‘ì¸ ë‹¤ë¥¸ ì—…ë°ì´íŠ¸ê°€ *ì—†ìŒ* ìœ¼ë¡œ, ReactëŠ” ê²°êµ­ 45ë¥¼ "í˜„ì¬ìƒíƒœ"(current state)ë¡œ ì €ì¥í•©ë‹ˆë‹¤.


  â—‹ By convention, itâ€™s common to name the pending state argument for the first letter of the state variable name, like a for age.
    However, you may also call it like prevAge or something else that you find clearer.
	------------------------------------
	ê´€ë¡€ì ìœ¼ë¡œ, ì—°ë ¹ê³¼ ê°™ì´ ìƒíƒœë³€ìˆ˜ ì´ë¦„ì˜ ì²«ê¸€ìì— ëŒ€í•´, ë³´ë¥˜ìƒíƒœ ì¸ìì˜ ì´ë¦„ì„ ì§€ì •í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.
	ê·¸ëŸ¬ë‚˜ prevAge ë˜ëŠ” ë” ëª…í™•í•˜ë‹¤ê³  ìƒê°ë˜ëŠ” ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ë¶€ë¥¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.


  â—‹ React may call your "updaters" *Twice* in development to verify that they are "pure".
	------------------------------------
	ReactëŠ” ê°œë°œì¤‘ì— "ìˆœìˆ˜"í•œ ì§€ í™•ì¸í•˜ê¸° ìœ„í•´, "ì—…ë°ì´í„°"ë¥¼ *ë‘ë²ˆ* í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


  â—‹ The difference between passing an updater and passing the next state directly:
	------------------------------------
	"ì—…ë°ì´íŠ¸ í”„ë¡œê·¸ë¨"ì„ "ì „ë‹¬"í•˜ëŠ” ê²ƒê³¼ "ë‹¤ìŒìƒíƒœ"ë¥¼ "ì§ì ‘ ì „ë‹¬"í•˜ëŠ” ê²ƒì˜ ì°¨ì´ì ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

	â‘  Example 1 of 2: Passing the "updater" function
	  - This example passes the "updater" function, so the â€œ+3â€ button works :


		import { useState } from 'react';				<--- ***

		export default function Counter() {
			const [age, setAge] = useState(42);			<--- ***

			function increment() {						<--- ***
				setAge(a => a + 1);						<--- ***
			}

			return (
				<>
					<h1>Your age: {age}</h1>

					<button onClick={() => {			<--- ***
						increment();					<--- ***
						increment();					<--- ***
						increment();					<--- ***
					}}>+3</button>

					<button onClick={() => {			<--- ***
						increment();					<--- ***
					}}>+1</button>
				</>
			);
		}


	â‘¡ Example 2 of 2: Passing the "next state directly" 
	  - This example does not pass the updater function, so the â€œ+3â€ button doesnâ€™t work as intended :


		import { useState } from 'react';				<--- ***

		export default function Counter() {
			const [age, setAge] = useState(42);			<--- ***

			function increment() {						<--- ***
				setAge(age + 1);						<--- ***
			}

			return (
				<>
					<h1>Your age: {age}</h1>
					
					<button onClick={() => {			<--- ***
						increment();					<--- ***
						increment();					<--- ***
						increment();					<--- ***
					}}>+3</button>
					<button onClick={() => {			<--- ***
						increment();					<--- ***
					}}>+1</button>
				</>
			);
		}


â–  Usage #3	- Updating "objects" and "arrays" in "state"

  â—‹ You can put objects and arrays into state.
  	In React, state is considered read-only, so you should replace it rather than mutate your existing objects.

  	For example, if you have a form object in state, donâ€™t mutate it:
	------------------------------------
	ê°ì²´ì™€ ë°°ì—´ì„ ìƒíƒœë¡œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	Reactì—ì„œ, ìƒíƒœëŠ” ì½ê¸° ì „ìš©ìœ¼ë¡œ ê°„ì£¼ë˜ë¯€ë¡œ ê¸°ì¡´ ê°ì²´ë¥¼ ë³€ê²½í•˜ê¸°ë³´ë‹¤ëŠ” ìƒíƒœë¥¼ êµì²´í•´ì•¼ í•©ë‹ˆë‹¤.
	
	ì˜ˆë¥¼ë“¤ì–´, ìƒíƒœì— ìˆëŠ” ì–‘ì‹ ê°ì²´ê°€ ìˆëŠ” ê²½ìš°, ì´ë¥¼ ë³€ê²½í•˜ì§€ ë§ˆì„¸ìš”:


		// ğŸš© Don't mutate an object in state like this:
		form.firstName = 'Taylor';


  â—‹ Instead, replace the whole object by creating a new one:
	------------------------------------
	ëŒ€ì‹ , ìƒˆ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬, ì „ì²´ ê°ì²´ë¥¼ êµì²´í•˜ì„¸ìš”:


		// âœ… Replace state with a new object
		setForm({
			...form,
			firstName: 'Taylor'
		});


---------------------------------
14. useSyncExternalStore
---------------------------------

â–  The "useSyncExternalStore" is a React Hook that lets you subscribe to an external store.
	(ì™¸ë¶€ ì €ì¥ì†Œë¥¼ êµ¬ë…í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React Hook)

	const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)


â–  Example

	import { useSyncExternalStore } from 'react';
	import { todosStore } from './todoStore.js';

	function TodosApp() {
		const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
		// ...
	}


---------------------------------
15. useTransition
---------------------------------

â–  The "useTransition" is a React Hook that lets you update the state without blocking the UI.
	(UIë¥¼ ì°¨ë‹¨í•˜ì§€ ì•Šê³ , ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆëŠ” React Hook)

	const [isPending, startTransition] = useTransition()


â–  Example 1

	import { useTransition } from 'react';

	function TabContainer() {
		const [isPending, startTransition] = useTransition();
		// ...
	}


â–  Example 2

	function TabContainer() {
		const [isPending, startTransition] = useTransition();
		const [tab, setTab] = useState('about');

		function selectTab(nextTab) {
			startTransition(() => {
			setTab(nextTab);
			});
		}

		// ...
	}

